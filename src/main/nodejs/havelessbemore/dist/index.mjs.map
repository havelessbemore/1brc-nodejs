{"version":3,"file":"index.mjs","sources":["../src/constants/constraints.ts","../src/constants/utf8.ts","../src/constants/stream.ts","../src/constants/workers.ts","../src/utils/stream.ts","../src/constants/utf8Trie.ts","../src/utils/utf8Trie.ts","../src/main.ts","../src/worker.ts","../src/index.ts"],"sourcesContent":["/**\n * The maximum number of entries in the file (i.e. 1 billion).\n */\nexport const MAX_ENTRIES = 1e9;\n\n/**\n * The maximum number of unique stations (i.e. 10 thousand).\n */\nexport const MAX_STATIONS = 1e4;\n\n/**\n * The maximum length in bytes of a station name (i.e. 100 bytes).\n */\nexport const STATION_NAME_MAX_LEN = 100;\n\n/**\n * The maximum length in bytes of an entry.\n *\n * Example: `Abha;71.3`\n * - Station name: 1-100 bytes\n * - Semicolon: 1 byte\n * - Temperature: 3-5 bytes\n * - Newline: 1 byte\n */\nexport const ENTRY_MAX_LEN = 107;\n","// UTF-8 char codes\n\n/**\n * The char code for a minus sign: -\n */\nexport const CHAR_MINUS = 45; // \"-\".charCodeAt(0);\n\n/**\n * The char code for a newline: \\n\n */\nexport const CHAR_NEWLINE = 10; // \"\\n\".charCodeAt(0);\n\n/**\n * The char code for a period: .\n */\nexport const CHAR_PERIOD = 46; // \".\".charCodeAt(0);\n\n/**\n * The char code for a semicolon: ;\n */\nexport const CHAR_SEMICOLON = 59; // \";\".charCodeAt(0);\n\n/**\n * The char code for a zero: 0\n */\nexport const CHAR_ZERO = 48; // \"0\".charCodeAt(0);\n\n// UTF-8 constants\n\n/**\n * The minimum value of the first byte of a UTF-8 code point.\n *\n * Ignores the control code points from U+0000 to U+001F.\n *\n * @see {@link https://www.charset.org/utf-8 | UTF-8 Charset}\n */\nexport const UTF8_B0_MIN = 32;\n\n/**\n * The minimum value for noninitial bytes of a UTF-8 code point.\n *\n * @see {@link https://en.wikipedia.org/wiki/UTF-8#Encoding | UTF-8 Encoding}\n */\nexport const UTF8_BN_MIN = 128;\n\nexport const UTF8_B0_1B_LEAD = 0b00000000;\nexport const UTF8_BN_LEAD = 0b10000000;\nexport const UTF8_B0_2B_LEAD = 0b11000000;\nexport const UTF8_B0_3B_LEAD = 0b11100000;\nexport const UTF8_B0_4B_LEAD = 0b11110000;\n\nexport const UTF8_B0_1B_LEAD_MASK = 0b10000000;\nexport const UTF8_BN_LEAD_MASK = 0b11000000;\nexport const UTF8_B0_2B_LEAD_MASK = 0b11100000;\nexport const UTF8_B0_3B_LEAD_MASK = 0b11110000;\nexport const UTF8_B0_4B_LEAD_MASK = 0b11111000;\n\nexport const UTF8_B0_1B_MAX = 0b01111111;\nexport const UTF8_BN_MAX = 0b10111111;\nexport const UTF8_B0_2B_MAX = 0b11011111;\nexport const UTF8_B0_3B_MAX = 0b11101111;\nexport const UTF8_B0_4B_MAX = 0b11110111;\nexport const UTF8_B0_MAX = UTF8_B0_4B_MAX;\n\nexport const UTF8_B0_1B_LEN = UTF8_B0_1B_MAX - UTF8_B0_MIN + 1;\nexport const UTF8_B0_2B_LEN = UTF8_B0_2B_MAX - UTF8_B0_MIN + 1;\nexport const UTF8_B0_3B_LEN = UTF8_B0_3B_MAX - UTF8_B0_MIN + 1;\nexport const UTF8_B0_4B_LEN = UTF8_B0_4B_MAX - UTF8_B0_MIN + 1;\nexport const UTF8_B0_LEN = UTF8_B0_MAX - UTF8_B0_MIN + 1;\nexport const UTF8_BN_LEN = UTF8_BN_MAX - UTF8_BN_MIN + 1;\n","import { CHAR_ZERO } from \"./utf8\";\n\n/**\n * The minimum value in bytes for `highWaterMark`.\n */\nexport const HIGH_WATER_MARK_MIN = 16384; // 16KiB\n\n/**\n * The maximum value in bytes for `highWaterMark`.\n */\nexport const HIGH_WATER_MARK_MAX = 1048576; // 1MiB\n\n/**\n * The `highWaterMark` for write streams.\n */\nexport const HIGH_WATER_MARK_OUT = 1048576; // 1MiB\n\n/**\n * The ratio of the file size to use for calculating\n * the `highWaterMark` of a stream.\n */\nexport const HIGH_WATER_MARK_RATIO = 0.000152;\n\n/**\n * The minimum size in bytes of a file chunk.\n */\nexport const CHUNK_SIZE_MIN = HIGH_WATER_MARK_MIN;\n\n// PARSE DOUBLE\n\n/**\n * Used to parse doubles from -9.9 to 9.9.\n */\nexport const CHAR_ZERO_11 = 11 * CHAR_ZERO;\n\n/**\n * Used to parse doubles from -99.9 to 99.9.\n */\nexport const CHAR_ZERO_111 = 111 * CHAR_ZERO;\n","/**\n * The minimum number of web workers (inclusive).\n */\nexport const MIN_WORKERS = 1;\n\n/**\n * The maximum number of web workers (inclusive).\n */\nexport const MAX_WORKERS = 512;\n","import { open } from \"fs/promises\";\n\nimport { CHAR_NEWLINE } from \"../constants/utf8\";\nimport {\n  HIGH_WATER_MARK_MAX,\n  HIGH_WATER_MARK_MIN,\n  HIGH_WATER_MARK_RATIO,\n} from \"../constants/stream\";\n\n/**\n * Clamp a value within a given range.\n *\n * @param value - The value to clamp.\n * @param min - The range min (inclusive).\n * @param max - The range max (inclusive).\n *\n * @returns The clamped value.\n */\nexport function clamp(value: number, min: number, max: number): number {\n  return value > min ? (value <= max ? value : max) : min;\n}\n\n/**\n * Splits a file into `target` chunks or less.\n *\n * - Each chunk is aligned to a file line;\n * i.e. file start, newline ('\\n') or file end.\n * - A chunk's size will be greater than or equal to `fileSize / target`.\n * - `target` chunks or less will be generated.\n *\n * @param filePath - The local path to the file to be chunked.\n * @param target - The target number of chunks to split the file into.\n * @param maxLineLength - The maximum length of a line in the file.\n * @param minSize - The minimum size of a chunk in bytes. Defaults to `0`.\n *\n * @returns A promise that resolves to an array of index pairs, where each\n * pair represents a chunk's start (inclusive) and end (exclusive) indices.\n *\n * @throws Will throw an error if the file cannot be opened or read.\n */\nexport async function getFileChunks(\n  filePath: string,\n  target: number,\n  maxLineLength: number,\n  minSize = 0,\n): Promise<[number, number][]> {\n  // Open the given file\n  const file = await open(filePath);\n  try {\n    // Get the file's size\n    const size = (await file.stat()).size;\n    // Calculate each chunk's target size\n    const chunkSize = Math.max(minSize, Math.floor(size / target));\n    // Initialize constants\n    const buffer = Buffer.allocUnsafe(maxLineLength);\n    const chunks: [number, number][] = [];\n    // Traverse the file, visiting each chunk's end index (exclusive)\n    let start = 0;\n    for (let end = chunkSize; end < size; end += chunkSize) {\n      // Read a line at the intended end index\n      const res = await file.read(buffer, 0, maxLineLength, end);\n      // Find the nearest newline ('\\n') character\n      const newline = buffer.indexOf(CHAR_NEWLINE);\n      // If found\n      if (newline >= 0 && newline < res.bytesRead) {\n        // Align end with the newline\n        end += newline + 1;\n        // Add the chunk\n        chunks.push([start, end]);\n        // Update the start index for the next chunk\n        start = end;\n      }\n    }\n    // Add the last chunk, if necessary\n    if (start < size) {\n      chunks.push([start, size]);\n    }\n    // Return chunks\n    return chunks;\n  } finally {\n    // Always close the file before returning\n    await file.close();\n  }\n}\n\n/**\n * Calculates an optimal highWaterMark value based on the given size.\n *\n * @param size - The size based on which the highWaterMark will be calculated.\n *\n * @returns The calculated highWaterMark value.\n */\nexport function getHighWaterMark(size: number): number {\n  // Get size percentage\n  size *= HIGH_WATER_MARK_RATIO;\n  // Get nearest power\n  size = Math.round(Math.log2(size));\n  // Calculate high water mark\n  size = 2 ** size;\n  // Clamp value\n  return clamp(size, HIGH_WATER_MARK_MIN, HIGH_WATER_MARK_MAX);\n}\n","import { UTF8_B0_2B_LEN } from \"./utf8\";\n\n// Trie static properties\n\n/**\n * Represents null / undefined.\n */\nexport const TRIE_NULL = 0;\n\n/**\n * The minimum size a trie.\n */\nexport const MIN_TRIE_SIZE = 524288; // 2 MiB\n\n/**\n * The default growth factor for growing the size of a trie.\n */\nexport const TRIE_GROWTH_FACTOR = 1.618; // ~phi\n\n/**\n * All trie properties are represented by 32 bits (4 bytes).\n */\nexport const TRIE_UNIT = Int32Array.BYTES_PER_ELEMENT;\n\n// Trie child pointer properties\n\nexport const TRIE_CHILD_IDX_IDX = 0;\nexport const TRIE_CHILD_IDX_MEM = 1;\n\nexport const TRIE_CHILD_MEM = TRIE_CHILD_IDX_MEM;\n\n// Trie redirect pointer properties\n\nexport const TRIE_RED_ID_IDX = 0;\nexport const TRIE_RED_ID_MEM = 1;\n\nexport const TRIE_RED_VALUE_IDX_IDX = 1;\nexport const TRIE_RED_VALUE_IDX_MEM = 1;\n\nexport const TRIE_RED_MEM = TRIE_RED_ID_MEM + TRIE_RED_VALUE_IDX_MEM;\n\n// Trie node properties\n\nexport const TRIE_NODE_ID_IDX = 0;\nexport const TRIE_NODE_ID_MEM = 1;\n\nexport const TRIE_NODE_VALUE_IDX_IDX = 1;\nexport const TRIE_NODE_VALUE_IDX_MEM = 1;\n\nexport const TRIE_NODE_CHILDREN_IDX = 2;\nexport const TRIE_NODE_CHILDREN_LEN = UTF8_B0_2B_LEN;\nexport const TRIE_NODE_CHILDREN_MEM = TRIE_CHILD_MEM * TRIE_NODE_CHILDREN_LEN;\n\nexport const TRIE_NODE_MEM =\n  TRIE_NODE_ID_MEM + TRIE_NODE_VALUE_IDX_MEM + TRIE_NODE_CHILDREN_MEM;\n\n// Trie properties\n\nexport const TRIE_SIZE_IDX = 0;\nexport const TRIE_SIZE_MEM = 1;\n\nexport const TRIE_ROOT_IDX = 1;\nexport const TRIE_ROOT_MEM = TRIE_NODE_MEM;\n\nexport const TRIE_ID_IDX = TRIE_ROOT_IDX + TRIE_NODE_ID_IDX;\nexport const TRIE_HEADER_MEM = TRIE_SIZE_MEM + TRIE_ROOT_MEM;\n","import { WriteStream } from \"node:fs\";\n\nimport {\n  MIN_TRIE_SIZE,\n  TRIE_CHILD_MEM,\n  TRIE_CHILD_IDX_IDX,\n  TRIE_GROWTH_FACTOR,\n  TRIE_HEADER_MEM,\n  TRIE_ID_IDX,\n  TRIE_NODE_CHILDREN_IDX,\n  TRIE_NODE_ID_IDX,\n  TRIE_NODE_VALUE_IDX_IDX,\n  TRIE_NULL,\n  TRIE_ROOT_IDX,\n  TRIE_SIZE_IDX,\n  TRIE_RED_MEM,\n  TRIE_RED_VALUE_IDX_IDX,\n  TRIE_RED_ID_IDX,\n  TRIE_NODE_MEM,\n  TRIE_NODE_CHILDREN_MEM,\n  TRIE_NODE_CHILDREN_LEN,\n} from \"../constants/utf8Trie\";\nimport { UTF8_B0_MIN } from \"../constants/utf8\";\n\nexport function add(\n  trie: Int32Array,\n  key: ArrayLike<number>,\n  min: number,\n  max: number,\n): [Int32Array, number] {\n  let index = TRIE_ROOT_IDX;\n  while (min < max) {\n    index +=\n      TRIE_NODE_CHILDREN_IDX + TRIE_CHILD_MEM * (key[min++] - UTF8_B0_MIN);\n    let child = trie[index + TRIE_CHILD_IDX_IDX];\n    if (child === TRIE_NULL) {\n      // Allocate new node\n      child = trie[TRIE_SIZE_IDX];\n      if (child + TRIE_NODE_MEM > trie.length) {\n        trie = grow(trie, child + TRIE_NODE_MEM);\n      }\n      trie[TRIE_SIZE_IDX] += TRIE_NODE_MEM;\n      // Attach and initialize node\n      trie[index + TRIE_CHILD_IDX_IDX] = child;\n      trie[child + TRIE_NODE_ID_IDX] = trie[TRIE_ID_IDX];\n    }\n    index = child;\n  }\n\n  return [trie, index];\n}\n\nexport function createTrie(id = 0, size = MIN_TRIE_SIZE): Int32Array {\n  const minSize = TRIE_HEADER_MEM;\n  const trie = new Int32Array(Math.max(minSize, size));\n  trie[TRIE_SIZE_IDX] = minSize;\n  trie[TRIE_ID_IDX] = id;\n  return trie;\n}\n\nexport function grow(trie: Int32Array, minSize = 0): Int32Array {\n  const length = trie[TRIE_SIZE_IDX];\n  minSize = Math.max(minSize, Math.ceil(length * TRIE_GROWTH_FACTOR));\n  const next = new Int32Array(minSize);\n  for (let i = 0; i < length; ++i) {\n    next[i] = trie[i];\n  }\n  return next;\n}\n\nexport function mergeLeft(\n  tries: Int32Array[],\n  at: number,\n  bt: number,\n  mergeFn: (ai: number, bi: number) => void,\n): void {\n  const queue: [number, number, number, number][] = [\n    [at, TRIE_ROOT_IDX, bt, TRIE_ROOT_IDX],\n  ];\n\n  do {\n    const Q = queue.length;\n    for (let q = 0; q < Q; ++q) {\n      let [at, ai, bt, bi] = queue[q];\n\n      // If right value is not null\n      const bvi = tries[bt][bi + TRIE_NODE_VALUE_IDX_IDX];\n      if (bvi !== TRIE_NULL) {\n        // If left value is not null\n        const avi = tries[at][ai + TRIE_NODE_VALUE_IDX_IDX];\n        if (avi !== TRIE_NULL) {\n          mergeFn(avi, bvi);\n        } else {\n          tries[at][ai + TRIE_NODE_VALUE_IDX_IDX] = bvi;\n        }\n      }\n\n      // Adjust to children property\n      ai += TRIE_NODE_CHILDREN_IDX;\n      bi += TRIE_NODE_CHILDREN_IDX;\n\n      // Traverse right children\n      const bn = bi + TRIE_NODE_CHILDREN_MEM;\n      while (bi < bn) {\n        // If right child is null\n        let ri = tries[bt][bi + TRIE_CHILD_IDX_IDX];\n        if (ri === TRIE_NULL) {\n          // Move to next children\n          ai += TRIE_CHILD_MEM;\n          bi += TRIE_CHILD_MEM;\n          continue;\n        }\n\n        // Resolve right child if redirect\n        const rt = tries[bt][ri + TRIE_NODE_ID_IDX];\n        if (bt !== rt) {\n          ri = tries[bt][ri + TRIE_RED_VALUE_IDX_IDX];\n        }\n\n        // If left child is null\n        let li = tries[at][ai + TRIE_CHILD_IDX_IDX];\n        if (li === TRIE_NULL) {\n          // Allocate new redirect in left trie\n          li = tries[at][TRIE_SIZE_IDX];\n          if (li + TRIE_RED_MEM > tries[at].length) {\n            tries[at] = grow(tries[at], li + TRIE_RED_MEM);\n          }\n          tries[at][TRIE_SIZE_IDX] += TRIE_RED_MEM;\n          // Add new redirect\n          tries[at][li + TRIE_RED_ID_IDX] = rt;\n          tries[at][li + TRIE_RED_VALUE_IDX_IDX] = ri;\n        } else {\n          // Resolve left child if redirect\n          const lt = tries[at][li + TRIE_NODE_ID_IDX];\n          if (at !== lt) {\n            ai = tries[at][li + TRIE_RED_VALUE_IDX_IDX];\n          }\n          // Merge children\n          queue.push([lt, li, rt, ri]);\n        }\n\n        // Move to next children\n        ai += TRIE_CHILD_MEM;\n        bi += TRIE_CHILD_MEM;\n      }\n    }\n    queue.splice(0, Q);\n  } while (queue.length > 0);\n}\n\nexport function print(\n  tries: Int32Array[],\n  key: Buffer,\n  trieIndex: number,\n  stream: WriteStream,\n  separator = \"\",\n  callbackFn: (\n    stream: WriteStream,\n    key: Buffer,\n    keyLen: number,\n    valueIndex: number,\n  ) => void,\n): void {\n  const stack: [number, number, number][] = new Array(key.length + 1);\n  stack[0] = [trieIndex, TRIE_ROOT_IDX + TRIE_NODE_CHILDREN_IDX, 0];\n\n  let top = 0;\n  let tail = false;\n  do {\n    let [trieI, childPtr, numChild] = stack[top];\n\n    // Check if end of children array\n    if (numChild >= TRIE_NODE_CHILDREN_LEN) {\n      --top;\n      continue;\n    }\n\n    // Update stack top\n    stack[top][1] += TRIE_CHILD_MEM;\n    ++stack[top][2];\n\n    // Check if child exists\n    let childI = tries[trieI][childPtr + TRIE_CHILD_IDX_IDX];\n    if (childI === TRIE_NULL) {\n      continue;\n    }\n\n    // Resolve redirect, if any\n    const childTrieI = tries[trieI][childI + TRIE_NODE_ID_IDX];\n    if (trieI !== childTrieI) {\n      childI = tries[trieI][childI + TRIE_RED_VALUE_IDX_IDX];\n      trieI = childTrieI;\n    }\n\n    // Add the child to the stack\n    key[top] = numChild + UTF8_B0_MIN;\n    stack[++top] = [trieI, childI + TRIE_NODE_CHILDREN_IDX, 0];\n\n    // Print value, if any\n    const valueIndex = tries[trieI][childI + TRIE_NODE_VALUE_IDX_IDX];\n    if (valueIndex !== TRIE_NULL) {\n      // Print separator if not first value\n      if (tail) {\n        stream.write(separator);\n      }\n      tail = true;\n      callbackFn(stream, key, top, valueIndex);\n    }\n  } while (top >= 0);\n}\n","import { WriteStream, createWriteStream } from \"node:fs\";\nimport { Worker } from \"node:worker_threads\";\n\nimport type { WorkerRequest } from \"./types/workerRequest\";\nimport type { WorkerResponse } from \"./types/workerResponse\";\n\nimport {\n  ENTRY_MAX_LEN,\n  MAX_STATIONS,\n  STATION_NAME_MAX_LEN,\n} from \"./constants/constraints\";\nimport { CHUNK_SIZE_MIN, HIGH_WATER_MARK_OUT } from \"./constants/stream\";\nimport { MAX_WORKERS, MIN_WORKERS } from \"./constants/workers\";\nimport { clamp, getFileChunks } from \"./utils/stream\";\nimport { mergeLeft, print } from \"./utils/utf8Trie\";\n\nexport async function run(\n  filePath: string,\n  workerPath: string,\n  maxWorkers: number,\n  outPath = \"\",\n): Promise<void> {\n  // Sanitize number of workers\n  maxWorkers = clamp(maxWorkers, MIN_WORKERS, MAX_WORKERS);\n\n  // Split the file into chunks. Creates 1 or fewer chunks per worker\n  const chunks = await getFileChunks(\n    filePath,\n    maxWorkers,\n    ENTRY_MAX_LEN,\n    CHUNK_SIZE_MIN,\n  );\n\n  // Adjust the number of workers to the number of chunks\n  maxWorkers = chunks.length;\n\n  // Initialize data\n  const numVals = MAX_STATIONS * maxWorkers + 1;\n  const counts = new Uint32Array(\n    new SharedArrayBuffer(Uint32Array.BYTES_PER_ELEMENT * numVals),\n  );\n  const minmaxes = new Int16Array(\n    new SharedArrayBuffer(2 * Int16Array.BYTES_PER_ELEMENT * numVals),\n  );\n  const sums = new Float64Array(\n    new SharedArrayBuffer(Float64Array.BYTES_PER_ELEMENT * numVals),\n  );\n  const tries: Int32Array[] = new Array(maxWorkers);\n\n  // Create workers\n  const workers = new Array<Worker>(maxWorkers);\n  for (let i = 0; i < maxWorkers; ++i) {\n    const worker = new Worker(workerPath);\n    worker.on(\"error\", (err) => {\n      throw err;\n    });\n    worker.on(\"messageerror\", (err) => {\n      throw err;\n    });\n    worker.on(\"exit\", (code) => {\n      if (code > 1 || code < 0) {\n        throw new Error(`Worker ${worker.threadId} exited with code ${code}`);\n      }\n    });\n    workers[i] = worker;\n  }\n\n  // Process each chunk\n  const tasks = new Array<Promise<WorkerResponse>>(maxWorkers);\n  for (let i = 0; i < maxWorkers; ++i) {\n    const id = i;\n    const worker = workers[i];\n    const [start, end] = chunks[i];\n    tasks[i] = new Promise((resolve) => {\n      worker.once(\"message\", resolve);\n      worker.postMessage({\n        counts,\n        end,\n        filePath,\n        id,\n        minmaxes,\n        start,\n        sums,\n      } as WorkerRequest);\n    });\n  }\n\n  // Wait for completion\n  for await (const res of tasks) {\n    tries[res.id] = res.trie;\n  }\n\n  // Terminate workers\n  for (let i = 0; i < maxWorkers; ++i) {\n    await workers[i].terminate();\n  }\n\n  // Merge tries\n  for (let i = 1; i < maxWorkers; ++i) {\n    mergeLeft(tries, 0, i, mergeStations);\n  }\n\n  // Print results\n  const out = createWriteStream(outPath, {\n    fd: outPath.length < 1 ? 1 : undefined,\n    flags: \"a\",\n    highWaterMark: HIGH_WATER_MARK_OUT,\n  });\n  const buffer = Buffer.allocUnsafe(STATION_NAME_MAX_LEN);\n  out.write(\"{\");\n  print(tries, buffer, 0, out, \", \", printStation);\n  out.end(\"}\\n\");\n\n  function mergeStations(ai: number, bi: number): void {\n    counts[ai] += counts[bi];\n    sums[ai] += sums[bi];\n    ai <<= 1;\n    bi <<= 1;\n    minmaxes[ai] = Math.min(minmaxes[ai], minmaxes[bi]);\n    minmaxes[ai + 1] = Math.max(minmaxes[ai + 1], minmaxes[bi + 1]);\n  }\n\n  function printStation(\n    stream: WriteStream,\n    name: Buffer,\n    nameLen: number,\n    vi: number,\n  ): void {\n    const avg = Math.round(sums[vi] / counts[vi]);\n    vi <<= 1;\n    stream.write(name.toString(\"utf8\", 0, nameLen));\n    stream.write(\"=\");\n    stream.write((minmaxes[vi] / 10).toFixed(1));\n    stream.write(\"/\");\n    stream.write((avg / 10).toFixed(1));\n    stream.write(\"/\");\n    stream.write((minmaxes[vi + 1] / 10).toFixed(1));\n  }\n}\n","import { createReadStream } from \"node:fs\";\n\nimport type { WorkerRequest } from \"./types/workerRequest\";\nimport type { WorkerResponse } from \"./types/workerResponse\";\n\nimport { CHAR_SEMICOLON } from \"./constants/utf8\";\nimport { CHAR_NEWLINE } from \"./constants/utf8\";\nimport { CHAR_MINUS } from \"./constants/utf8\";\nimport { ENTRY_MAX_LEN, MAX_STATIONS } from \"./constants/constraints\";\nimport { CHAR_ZERO_11, CHAR_ZERO_111 } from \"./constants/stream\";\nimport { TRIE_NODE_VALUE_IDX_IDX, TRIE_NULL } from \"./constants/utf8Trie\";\nimport { getHighWaterMark } from \"./utils/stream\";\nimport { add, createTrie } from \"./utils/utf8Trie\";\n\nexport async function run({\n  end,\n  filePath,\n  id,\n  start,\n  // Shared memory\n  counts,\n  minmaxes,\n  sums,\n}: WorkerRequest): Promise<WorkerResponse> {\n  // Check chunk size\n  if (start >= end) {\n    return { id, trie: createTrie(id, 0) };\n  }\n\n  // Initialize constants\n  let trie = createTrie(id);\n  let stations = id * MAX_STATIONS + 1;\n  const buffer = Buffer.allocUnsafe(ENTRY_MAX_LEN);\n\n  // Create the chunk stream\n  const stream = createReadStream(filePath, {\n    start,\n    end: end - 1,\n    highWaterMark: getHighWaterMark(end - start),\n  });\n\n  // For each chunk\n  let bufI = 0;\n  let tempI = 0;\n  let leaf: number;\n  for await (const chunk of stream) {\n    // For each byte\n    const N = chunk.length;\n    for (let i = 0; i < N; ++i) {\n      if (chunk[i] === CHAR_SEMICOLON) {\n        // If semicolon\n        tempI = bufI;\n      } else if (chunk[i] !== CHAR_NEWLINE) {\n        // If not newline\n        buffer[bufI++] = chunk[i];\n      } else {\n        // Get temperature\n        const tempV = parseDouble(buffer, tempI, bufI);\n        bufI = 0;\n        // Add the station's name to the trie and get leaf index\n        [trie, leaf] = add(trie, buffer, 0, tempI);\n        // If the station existed\n        if (trie[leaf + TRIE_NODE_VALUE_IDX_IDX] !== TRIE_NULL) {\n          // Update the station's value\n          updateStation(trie[leaf + TRIE_NODE_VALUE_IDX_IDX], tempV);\n        } else {\n          // Add the new station's value\n          trie[leaf + TRIE_NODE_VALUE_IDX_IDX] = stations;\n          newStation(stations++, tempV);\n        }\n      }\n    }\n  }\n\n  function newStation(index: number, temp: number): void {\n    counts[index] = 1;\n    sums[index] = temp;\n    index <<= 1;\n    minmaxes[index] = temp;\n    minmaxes[index + 1] = temp;\n  }\n\n  function updateStation(index: number, temp: number): void {\n    ++counts[index];\n    sums[index] += temp;\n    index <<= 1;\n    minmaxes[index] = minmaxes[index] <= temp ? minmaxes[index] : temp;\n    ++index;\n    minmaxes[index] = minmaxes[index] >= temp ? minmaxes[index] : temp;\n  }\n\n  return { id, trie };\n}\n\nexport function parseDouble(b: Buffer, min: number, max: number): number {\n  if (b[min] === CHAR_MINUS) {\n    ++min;\n    return min + 4 > max\n      ? -(10 * b[min] + b[min + 2] - CHAR_ZERO_11)\n      : -(100 * b[min] + 10 * b[min + 1] + b[min + 3] - CHAR_ZERO_111);\n  }\n  return min + 4 > max\n    ? 10 * b[min] + b[min + 2] - CHAR_ZERO_11\n    : 100 * b[min] + 10 * b[min + 1] + b[min + 3] - CHAR_ZERO_111;\n}\n","import { availableParallelism } from \"node:os\";\nimport { fileURLToPath } from \"node:url\";\nimport { isMainThread, parentPort } from \"node:worker_threads\";\n\nimport type { WorkerRequest } from \"./types/workerRequest\";\n\nimport { run as runMain } from \"./main\";\nimport { run as runWorker } from \"./worker\";\n\nif (isMainThread) {\n  const workerPath = fileURLToPath(import.meta.url);\n  runMain(process.argv[2], workerPath, availableParallelism());\n} else {\n  parentPort!.addListener(\"message\", async (req: WorkerRequest) => {\n    const res = await runWorker(req);\n    parentPort!.postMessage(res, [res.trie.buffer]);\n  });\n}\n"],"names":["at","bt","run","runMain","runWorker"],"mappings":"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"}