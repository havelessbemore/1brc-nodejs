{
  "version": 3,
  "sources": ["../src/index.ts", "../src/main.ts", "../src/utils/stream.ts", "../src/utils/utf8Trie.ts", "../src/utils/worker.ts", "../src/worker.ts", "../src/utils/parse.ts"],
  "sourcesContent": ["import { availableParallelism } from \"node:os\";\nimport { fileURLToPath } from \"node:url\";\nimport { isMainThread, parentPort } from \"node:worker_threads\";\n\nimport type { MergeRequest } from \"./types/mergeRequest\";\nimport type { ProcessRequest } from \"./types/processRequest\";\nimport { RequestType, type Request } from \"./types/request\";\n\nimport { run as runMain } from \"./main\";\nimport { merge, run as runWorker } from \"./worker\";\n\nif (isMainThread) {\n  const workerPath = fileURLToPath(import.meta.url);\n  runMain(process.argv[2], workerPath, availableParallelism());\n} else {\n  parentPort!.addListener(\"message\", (msg: Request) => {\n    if (msg.type === RequestType.PROCESS) {\n      parentPort!.postMessage(runWorker(msg as ProcessRequest));\n    } else if (msg.type === RequestType.MERGE) {\n      parentPort!.postMessage(merge(msg as MergeRequest));\n    } else {\n      throw new Error(\"Unknown message type\");\n    }\n  });\n}\n", "import {\n  closeSync,\n  createWriteStream,\n  fstatSync,\n  openSync,\n  WriteStream,\n} from \"node:fs\";\nimport { stdout } from \"node:process\";\n\nimport type { MergeRequest } from \"./types/mergeRequest\";\nimport type { MergeResponse } from \"./types/mergeResponse\";\nimport type { ProcessRequest } from \"./types/processRequest\";\nimport type { ProcessResponse } from \"./types/processResponse\";\n\nimport { BRC } from \"./constants/brc\";\nimport { Config } from \"./constants/config\";\nimport { RequestType } from \"./types/request\";\nimport { clamp, getChunkSize, getPageSize } from \"./utils/stream\";\nimport { print } from \"./utils/utf8Trie\";\nimport { createWorker, exec } from \"./utils/worker\";\n\nexport async function run(\n  filePath: string,\n  workerPath: string,\n  maxWorkers: number,\n  outPath = \"\",\n): Promise<void> {\n  // Sanitize number of workers\n  maxWorkers = clamp(maxWorkers, Config.WORKERS_MIN, Config.WORKERS_MAX);\n\n  // Open the given file\n  const fd = openSync(filePath, \"r\");\n\n  // Get file stats\n  const fstats = fstatSync(fd);\n  const fileSize = fstats.size;\n  const pageSize = getPageSize(fileSize, maxWorkers);\n  const chunkSize = getChunkSize(pageSize);\n\n  // Initialize data\n  const valBuf = new SharedArrayBuffer(\n    (BRC.MAX_STATIONS * maxWorkers + 1) << 4,\n  );\n  const page = new Uint32Array(valBuf, 0, 1);\n  const mins = new Int16Array(valBuf);\n  const maxes = new Int16Array(valBuf, 2);\n  const counts = new Uint32Array(valBuf, 4);\n  const sums = new Float64Array(valBuf, 8);\n  const tries = new Array<Int32Array>(maxWorkers);\n\n  // Run\n  const unmerged: number[] = [];\n  const tasks = new Array<Promise<unknown>>(maxWorkers);\n  for (let i = 0; i < maxWorkers; ++i) {\n    // Create the worker\n    const worker = createWorker(workerPath);\n    // Process the chunk\n    tasks[i] = exec<ProcessRequest, ProcessResponse>(worker, {\n      type: RequestType.PROCESS,\n      id: i,\n      // I/O\n      fd,\n      fileSize,\n      pageSize,\n      chunkSize,\n      // Shared memory\n      counts,\n      maxes,\n      mins,\n      page,\n      sums,\n    }).then(async (res) => {\n      // Add result to trie array\n      const a = res.id;\n      tries[a] = res.trie;\n      // Merge with other tries\n      while (unmerged.length > 0) {\n        const res = await exec<MergeRequest, MergeResponse>(worker, {\n          type: RequestType.MERGE,\n          a,\n          b: unmerged.pop()!,\n          counts,\n          maxes,\n          mins,\n          sums,\n          tries,\n        });\n        // Update the trie array\n        for (const id of res.ids) {\n          tries[id] = res.tries[id];\n        }\n      }\n      unmerged.push(a);\n      // Stop worker\n      return worker.terminate();\n    });\n  }\n\n  // Wait for completion\n  await Promise.all(tasks);\n\n  // Close the file\n  closeSync(fd);\n\n  // Print results\n  const out = createWriteStream(outPath, {\n    fd: outPath.length < 1 ? stdout.fd : undefined,\n    flags: \"a\",\n    highWaterMark: Config.HIGH_WATER_MARK_OUT,\n  });\n  const buffer = Buffer.allocUnsafe(BRC.MAX_STATION_NAME_LEN);\n  out.write(\"{\");\n  print(tries, buffer, unmerged[0], out, \", \", printStation);\n  out.end(\"}\\n\");\n\n  function printStation(\n    stream: WriteStream,\n    name: Buffer,\n    nameLen: number,\n    vi: number,\n  ): void {\n    const avg = Math.round(sums[vi << 1] / counts[vi << 2]);\n    stream.write(name.toString(\"utf8\", 0, nameLen));\n    stream.write(\"=\");\n    stream.write((mins[vi << 3] / 10).toFixed(1));\n    stream.write(\"/\");\n    stream.write((avg / 10).toFixed(1));\n    stream.write(\"/\");\n    stream.write((maxes[vi << 3] / 10).toFixed(1));\n  }\n}\n", "import { Config } from \"../constants/config\";\n\n/**\n * Clamp a value within a given range.\n *\n * @param value - The value to clamp.\n * @param min - The range min (inclusive).\n * @param max - The range max (inclusive).\n *\n * @returns The clamped value.\n */\nexport function clamp(value: number, min: number, max: number): number {\n  return value > min ? (value <= max ? value : max) : min;\n}\n\n/**\n * Calculates a chunk size based on a given page size.\n *\n * @param size - The page size.\n *\n * @returns The calculated chunk size.\n */\nexport function getChunkSize(size: number): number {\n  // Get size percentage\n  size = Math.ceil(size * Config.CHUNK_SIZE_RATIO);\n  // Align\n  size += Config.SYS_PAGE_SIZE - (size % Config.SYS_PAGE_SIZE);\n  // Clamp value\n  return clamp(size, Config.CHUNK_SIZE_MIN, Config.CHUNK_SIZE_MAX);\n}\n\n/**\n * Calculates a page size based on a given file size.\n *\n * @param fileSize - The file size.\n * @param workers - The number of workers the file will be split across.\n *\n * @returns The calculated page size.\n */\nexport function getPageSize(fileSize: number, workers: number): number {\n  // Divide into workers\n  fileSize = Math.ceil(fileSize / workers);\n  // Align\n  fileSize += Config.SYS_PAGE_SIZE - (fileSize % Config.SYS_PAGE_SIZE);\n  // Clamp value\n  return clamp(fileSize, Config.PAGE_SIZE_MIN, Config.PAGE_SIZE_MAX);\n}\n\n/**\n * Returns the index of the last occurrence of a\n * specified value in an array, or `-1` if it's not present.\n *\n * @param array - The array to search through.\n * @param searchElement \u2014 The value to locate in the array.\n * @param max \u2014 The array index at which to begin searching backward.\n *\n * @returns the index of the last occurrence, or `-1` if it's not present.\n */\nexport function lastIndexOf<T>(\n  array: ArrayLike<T>,\n  searchElement: T,\n  max: number,\n): number {\n  while (--max >= 0) {\n    if (array[max] === searchElement) {\n      return max;\n    }\n  }\n  return -1;\n}\n", "import { WriteStream } from \"node:fs\";\n\nimport {\n  Trie,\n  TrieNodeProto,\n  TrieProto,\n  TriePointerProto,\n  TrieRedirectProto,\n  UTF8,\n} from \"../constants/utf8\";\n\nexport function add(\n  trie: Int32Array,\n  key: ArrayLike<number>,\n  min: number,\n  max: number,\n): [Int32Array, number] {\n  let index: number = TrieProto.ROOT_IDX;\n  while (min < max) {\n    index +=\n      TrieNodeProto.CHILDREN_IDX +\n      TriePointerProto.MEM * (key[min++] - UTF8.BYTE_MIN);\n    let child = trie[index + TriePointerProto.IDX_IDX];\n    if (child === Trie.NULL) {\n      // Allocate node\n      child = trie[TrieProto.SIZE_IDX];\n      if (child + TrieNodeProto.MEM > trie.length) {\n        trie = grow(trie, child + TrieNodeProto.MEM);\n      }\n      trie[TrieProto.SIZE_IDX] += TrieNodeProto.MEM;\n      // Attach node\n      trie[index + TriePointerProto.IDX_IDX] = child;\n      // Initialize node\n      trie[child + TrieNodeProto.ID_IDX] = trie[TrieProto.ID_IDX];\n    }\n    index = child;\n  }\n\n  return [trie, index];\n}\n\nexport function get(\n  tries: Int32Array[],\n  trie: number,\n  key: ArrayLike<number>,\n  min: number,\n  max: number,\n): number | undefined {\n  let node: number = TrieProto.ROOT_IDX;\n  while (min < max) {\n    const ptr =\n      node +\n      TrieNodeProto.CHILDREN_IDX +\n      TriePointerProto.MEM * (key[min++] - UTF8.BYTE_MIN);\n    let child = tries[trie][ptr + TriePointerProto.IDX_IDX];\n    if (child === Trie.NULL) {\n      return undefined;\n    }\n    // Resolve redirect, if any\n    const childTrie = tries[trie][child + TrieNodeProto.ID_IDX];\n    if (childTrie !== trie) {\n      child = tries[trie][child + TrieRedirectProto.IDX_IDX];\n      trie = childTrie;\n    }\n    node = child;\n  }\n  return node;\n}\n\nexport function createTrie(id = 0, size = Trie.DEFAULT_SIZE): Int32Array {\n  size = Math.max(TrieProto.MEM, size);\n  const trie = new Int32Array(new SharedArrayBuffer(size << 2));\n  trie[TrieProto.SIZE_IDX] = TrieProto.MEM;\n  trie[TrieProto.ID_IDX] = id;\n  return trie;\n}\n\nexport function grow(trie: Int32Array, minSize = 0): Int32Array {\n  const length = trie[TrieProto.SIZE_IDX];\n  minSize = Math.max(minSize, Math.ceil(length * Trie.GROWTH_FACTOR));\n  const next = new Int32Array(new SharedArrayBuffer(minSize << 2));\n  for (let i = 0; i < length; ++i) {\n    next[i] = trie[i];\n  }\n  return next;\n}\n\nexport function mergeLeft(\n  tries: Int32Array[],\n  at: number,\n  bt: number,\n  mergeFn: (ai: number, bi: number) => void,\n): number[] {\n  const grown: number[] = [];\n  const queue: [number, number, number, number][] = [\n    [at, TrieProto.ROOT_IDX, bt, TrieProto.ROOT_IDX],\n  ];\n\n  do {\n    const Q = queue.length;\n    for (let q = 0; q < Q; ++q) {\n      // eslint-disable-next-line prefer-const\n      let [at, ai, bt, bi] = queue[q];\n\n      // If right value is not null\n      const bvi = tries[bt][bi + TrieNodeProto.VALUE_IDX];\n      if (bvi !== Trie.NULL) {\n        // If left value is not null\n        const avi = tries[at][ai + TrieNodeProto.VALUE_IDX];\n        if (avi !== Trie.NULL) {\n          mergeFn(avi, bvi);\n        } else {\n          tries[at][ai + TrieNodeProto.VALUE_IDX] = bvi;\n        }\n      }\n\n      // Adjust to children property\n      ai += TrieNodeProto.CHILDREN_IDX;\n      bi += TrieNodeProto.CHILDREN_IDX;\n\n      // Traverse right children\n      const bn = bi + TrieNodeProto.CHILDREN_MEM;\n      while (bi < bn) {\n        // If right child is null\n        let ri = tries[bt][bi + TriePointerProto.IDX_IDX];\n        if (ri !== Trie.NULL) {\n          // Resolve right child if redirect\n          const rt = tries[bt][ri + TrieNodeProto.ID_IDX];\n          if (bt !== rt) {\n            ri = tries[bt][ri + TrieRedirectProto.IDX_IDX];\n          }\n\n          // If left child is null\n          let li = tries[at][ai + TriePointerProto.IDX_IDX];\n          if (li === Trie.NULL) {\n            // Allocate redirect\n            li = tries[at][TrieProto.SIZE_IDX];\n            if (li + TrieRedirectProto.MEM > tries[at].length) {\n              tries[at] = grow(tries[at], li + TrieRedirectProto.MEM);\n              grown.push(at);\n            }\n            tries[at][TrieProto.SIZE_IDX] += TrieRedirectProto.MEM;\n            // Attach redirect\n            tries[at][ai + TriePointerProto.IDX_IDX] = li;\n            // Initialize redirect\n            tries[at][li + TrieRedirectProto.ID_IDX] = rt;\n            tries[at][li + TrieRedirectProto.IDX_IDX] = ri;\n          } else {\n            // Resolve left child if redirect\n            const lt = tries[at][li + TrieNodeProto.ID_IDX];\n            if (at !== lt) {\n              li = tries[at][li + TrieRedirectProto.IDX_IDX];\n            }\n            // Merge children\n            queue.push([lt, li, rt, ri]);\n          }\n        }\n\n        // Move to next children\n        ai += TriePointerProto.MEM;\n        bi += TriePointerProto.MEM;\n      }\n    }\n    queue.splice(0, Q);\n  } while (queue.length > 0);\n  return grown;\n}\n\nexport function print(\n  tries: Int32Array[],\n  key: Buffer,\n  trieIndex: number,\n  stream: WriteStream,\n  separator = \"\",\n  callbackFn: (\n    stream: WriteStream,\n    key: Buffer,\n    keyLen: number,\n    valueIndex: number,\n  ) => void,\n): void {\n  const stack = new Array<[number, number, number]>(key.length + 1);\n  stack[0] = [trieIndex, TrieProto.ROOT_IDX + TrieNodeProto.CHILDREN_IDX, 0];\n\n  let top = 0;\n  let tail = false;\n  do {\n    // eslint-disable-next-line prefer-const\n    let [trieI, childPtr, numChild] = stack[top];\n\n    // Check if end of children array\n    if (numChild >= TrieNodeProto.CHILDREN_LEN) {\n      --top;\n      continue;\n    }\n\n    // Update stack top\n    stack[top][1] += TriePointerProto.MEM;\n    ++stack[top][2];\n\n    // Check if child exists\n    let childI = tries[trieI][childPtr + TriePointerProto.IDX_IDX];\n    if (childI === Trie.NULL) {\n      continue;\n    }\n\n    // Resolve redirect, if any\n    const childTrieI = tries[trieI][childI + TrieNodeProto.ID_IDX];\n    if (trieI !== childTrieI) {\n      childI = tries[trieI][childI + TrieRedirectProto.IDX_IDX];\n      trieI = childTrieI;\n    }\n\n    // Add the child to the stack\n    key[top] = numChild + UTF8.BYTE_MIN;\n    stack[++top] = [trieI, childI + TrieNodeProto.CHILDREN_IDX, 0];\n\n    // Print value, if any\n    const valueIndex = tries[trieI][childI + TrieNodeProto.VALUE_IDX];\n    if (valueIndex !== Trie.NULL) {\n      // Print separator if not first value\n      if (tail) {\n        stream.write(separator);\n      }\n      tail = true;\n      callbackFn(stream, key, top, valueIndex);\n    }\n  } while (top >= 0);\n}\n", "import { Worker } from \"node:worker_threads\";\n\n/**\n * Creates a new Worker instance.\n *\n * @param workerPath - The path to the worker script.\n *\n * @returns A new Worker instance.\n */\nexport function createWorker(workerPath: string): Worker {\n  const worker = new Worker(workerPath);\n  worker.on(\"error\", (err) => {\n    throw err;\n  });\n  worker.on(\"messageerror\", (err) => {\n    throw err;\n  });\n  worker.on(\"exit\", (code) => {\n    if (code > 1 || code < 0) {\n      throw new Error(`Worker ${worker.threadId} exited with code ${code}`);\n    }\n  });\n  return worker;\n}\n\n/**\n * Executes a task on a Worker and returns a Promise that resolves with the response.\n *\n * @param worker - The Worker instance to execute the task.\n * @param req - The request to send to the worker.\n *\n * @returns A Promise that resolves with the response from the worker.\n */\nexport function exec<Req, Res>(worker: Worker, req: Req): Promise<Res> {\n  return new Promise<Res>((resolve) => {\n    worker.once(\"message\", resolve);\n    worker.postMessage(req);\n  });\n}\n", "import { readSync } from \"fs\";\n\nimport type { MergeRequest } from \"./types/mergeRequest\";\nimport type { MergeResponse } from \"./types/mergeResponse\";\nimport type { ProcessRequest } from \"./types/processRequest\";\nimport type { ProcessResponse } from \"./types/processResponse\";\n\nimport { BRC } from \"./constants/brc\";\nimport { CharCode, Trie, TrieNodeProto } from \"./constants/utf8\";\nimport { parseDouble } from \"./utils/parse\";\nimport { add, createTrie, mergeLeft } from \"./utils/utf8Trie\";\nimport { lastIndexOf } from \"./utils/stream\";\nimport { Config } from \"./constants/config\";\n\nexport function run({\n  id,\n  // I/O\n  fd,\n  fileSize,\n  pageSize,\n  chunkSize,\n  // Shared memory\n  counts,\n  maxes,\n  mins,\n  page,\n  sums,\n}: ProcessRequest): ProcessResponse {\n  const newStation = (index: number, temp: number): void => {\n    mins[index << 3] = temp;\n    maxes[index << 3] = temp;\n    counts[index << 2] = 1;\n    sums[index << 1] = temp;\n  };\n\n  const updateStation = (index: number, temp: number): void => {\n    index <<= 3;\n    mins[index] = mins[index] <= temp ? mins[index] : temp;\n    maxes[index] = maxes[index] >= temp ? maxes[index] : temp;\n    ++counts[index >> 1];\n    sums[index >> 2] += temp;\n  };\n\n  // Initialize constants\n  const chunk = Buffer.allocUnsafe(chunkSize + Config.SYS_PAGE_SIZE);\n  let stations = id * BRC.MAX_STATIONS;\n  let trie = createTrie(id);\n\n  // For each page\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    // Get page start\n    let start = pageSize * Atomics.add(page, 0, 1);\n    if (start >= fileSize) {\n      break;\n    }\n\n    // Align start with entry\n    let bufI = start > 0 ? Config.SYS_PAGE_SIZE : 0;\n    readSync(fd, chunk, 0, bufI, start - bufI);\n    let minI = lastIndexOf(chunk, CharCode.NEWLINE, bufI);\n\n    // For each chunk\n    const end = Math.min(fileSize, start + pageSize);\n    for (++minI; start < end; start += chunkSize) {\n      // Move incomplete entry to start of buffer\n      let maxI = Config.SYS_PAGE_SIZE - bufI + minI;\n      chunk.copyWithin(maxI, minI, bufI);\n      bufI = Config.SYS_PAGE_SIZE;\n      minI = maxI;\n\n      // Read the chunk into memory\n      maxI = Math.min(chunkSize, end - start);\n      maxI = readSync(fd, chunk, bufI, maxI, start);\n\n      // For each byte\n      for (maxI += bufI; bufI < maxI; ++bufI) {\n        // If not newline\n        if (chunk[bufI] !== CharCode.NEWLINE) {\n          continue;\n        }\n\n        // Get semicolon\n        let semI = bufI - 5;\n        if (chunk[semI] !== CharCode.SEMICOLON) {\n          semI += 1 | (1 + ~(chunk[semI - 1] === CharCode.SEMICOLON));\n        }\n\n        // Add the station's name to the trie and get leaf\n        let leaf: number;\n        [trie, leaf] = add(trie, chunk, minI, semI);\n\n        // Update next entry's min\n        minI = bufI + 1;\n\n        // Get temperature\n        const temp = parseDouble(chunk, semI + 1, bufI);\n\n        // If the station existed\n        leaf += TrieNodeProto.VALUE_IDX;\n        if (trie[leaf] !== Trie.NULL) {\n          // Update the station's value\n          updateStation(trie[leaf], temp);\n        } else {\n          // Add the new station's value\n          trie[leaf] = ++stations;\n          newStation(stations, temp);\n        }\n      }\n    }\n  }\n\n  return { id, trie };\n}\n\nexport function merge({\n  a,\n  b,\n  tries,\n  counts,\n  maxes,\n  mins,\n  sums,\n}: MergeRequest): MergeResponse {\n  const ids = mergeLeft(tries, a, b, (ai: number, bi: number): void => {\n    ai <<= 3;\n    bi <<= 3;\n    mins[ai] = mins[ai] <= mins[bi] ? mins[ai] : mins[bi];\n    maxes[ai] = maxes[ai] >= maxes[bi] ? maxes[ai] : maxes[bi];\n    counts[ai >> 1] += counts[bi >> 1];\n    sums[ai >> 2] += sums[bi >> 2];\n  });\n  return { ids, tries };\n}\n", "import { CharCode } from \"../constants/utf8\";\n\nexport const CHAR_ZERO_11 = 11 * CharCode.ZERO;\nexport const CHAR_ZERO_111 = 111 * CharCode.ZERO;\n\n/**\n * Converts an ASCII numeric string into an integer.\n *\n * Fastest.\n */\nexport function parseDouble(b: Buffer, min: number, max: number): number {\n  if (b[min] === CharCode.MINUS) {\n    ++min;\n    return min + 4 > max\n      ? CHAR_ZERO_11 - 10 * b[min] - b[min + 2]\n      : CHAR_ZERO_111 - 100 * b[min] - 10 * b[min + 1] - b[min + 3];\n  }\n  return min + 4 > max\n    ? 10 * b[min] + b[min + 2] - CHAR_ZERO_11\n    : 100 * b[min] + 10 * b[min + 1] + b[min + 3] - CHAR_ZERO_111;\n}\n\n/**\n * Converts an ASCII numeric string into an integer.\n *\n * Second fastest.\n */\nexport function parseDoubleFlat(b: Buffer, min: number, max: number): number {\n  const sign = -(b[min] === CharCode.MINUS);\n  b[min + ~sign] = CharCode.ZERO;\n  return (\n    ((100 * b[max - 4] + 10 * b[max - 3] + b[max - 1] - CHAR_ZERO_111) ^ sign) -\n    sign\n  );\n}\n\n/**\n * Converts an ASCII numeric string into an integer without branching.\n *\n * Inspired by {@link https://github.com/gunnarmorling/1brc/blob/main/src/main/java/dev/morling/onebrc/CalculateAverage_thomaswue.java#L68 | Quan Anh Mai's method}.\n *\n * Slowest.\n */\nexport function parseDoubleQuan(b: Buffer, min: number, max: number): number {\n  b[min - 1] = 0;\n  const sign = -(b[min] === CharCode.MINUS);\n  const signMask = -(min + 4 >= max) & sign & 0xff000000;\n  let v = b.readUint32BE(max - 4) & ~signMask & 0x0f0f000f;\n  v = (v & 0xff000000) * 0x19 + (v & 0x00ff0000) * 0x280 + (v << 22);\n  return ((v >>> 22) ^ sign) - sign;\n}\n"],
  "mappings": "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",
  "names": ["availableParallelism", "fileURLToPath", "isMainThread", "parentPort", "closeSync", "createWriteStream", "fstatSync", "openSync", "stdout", "clamp", "value", "min", "max", "getChunkSize", "size", "getPageSize", "fileSize", "workers", "lastIndexOf", "array", "searchElement", "add", "trie", "key", "min", "max", "index", "child", "grow", "createTrie", "id", "size", "trie", "grow", "minSize", "length", "next", "i", "mergeLeft", "tries", "at", "bt", "mergeFn", "grown", "queue", "Q", "q", "ai", "bi", "bvi", "avi", "bn", "ri", "rt", "li", "lt", "print", "key", "trieIndex", "stream", "separator", "callbackFn", "stack", "top", "tail", "trieI", "childPtr", "numChild", "childI", "childTrieI", "valueIndex", "Worker", "createWorker", "workerPath", "worker", "err", "code", "exec", "req", "resolve", "run", "filePath", "workerPath", "maxWorkers", "outPath", "clamp", "fd", "openSync", "fileSize", "fstatSync", "pageSize", "getPageSize", "chunkSize", "getChunkSize", "valBuf", "page", "mins", "maxes", "counts", "sums", "tries", "unmerged", "tasks", "i", "worker", "createWorker", "exec", "res", "a", "id", "closeSync", "out", "createWriteStream", "stdout", "buffer", "print", "printStation", "stream", "name", "nameLen", "vi", "avg", "readSync", "CHAR_ZERO_11", "CHAR_ZERO_111", "parseDouble", "b", "min", "max", "run", "id", "fd", "fileSize", "pageSize", "chunkSize", "counts", "maxes", "mins", "page", "sums", "newStation", "index", "temp", "updateStation", "chunk", "stations", "trie", "createTrie", "start", "bufI", "readSync", "minI", "lastIndexOf", "end", "maxI", "semI", "leaf", "add", "parseDouble", "merge", "a", "b", "tries", "mergeLeft", "ai", "bi", "isMainThread", "workerPath", "fileURLToPath", "run", "availableParallelism", "parentPort", "msg", "merge"]
}
