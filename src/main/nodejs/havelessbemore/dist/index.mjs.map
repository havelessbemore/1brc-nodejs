{"version":3,"file":"index.mjs","sources":["../src/constants/constraints.ts","../src/constants/utf8.ts","../src/constants/stream.ts","../src/constants/workers.ts","../src/utils/stream.ts","../src/constants/utf8Trie.ts","../src/utils/utf8Trie.ts","../src/utils/worker.ts","../src/main.ts","../src/worker.ts","../src/index.ts"],"sourcesContent":["/**\n * The maximum number of entries in the file (i.e. 1 billion).\n */\nexport const MAX_ENTRIES = 1e9;\n\n/**\n * The maximum number of unique stations (i.e. 10 thousand).\n */\nexport const MAX_STATIONS = 1e4;\n\n/**\n * The maximum length in bytes of a station name (i.e. 100 bytes).\n */\nexport const STATION_NAME_MAX_LEN = 100;\n\n/**\n * The maximum length in bytes of an entry.\n *\n * Example: `Abha;71.3`\n * - Station name: 1-100 bytes\n * - Semicolon: 1 byte\n * - Temperature: 3-5 bytes\n * - Newline: 1 byte\n */\nexport const ENTRY_MAX_LEN = 107;\n","// UTF-8 char codes\n\n/**\n * The char code for a minus sign: -\n */\nexport const CHAR_MINUS = 45; // \"-\".charCodeAt(0);\n\n/**\n * The char code for a newline: \\n\n */\nexport const CHAR_NEWLINE = 10; // \"\\n\".charCodeAt(0);\n\n/**\n * The char code for a period: .\n */\nexport const CHAR_PERIOD = 46; // \".\".charCodeAt(0);\n\n/**\n * The char code for a semicolon: ;\n */\nexport const CHAR_SEMICOLON = 59; // \";\".charCodeAt(0);\n\n/**\n * The char code for a zero: 0\n */\nexport const CHAR_ZERO = 48; // \"0\".charCodeAt(0);\n\n// UTF-8 constants\n\n/**\n * The minimum value of the first byte of a UTF-8 code point.\n *\n * Ignores the control code points from U+0000 to U+001F.\n *\n * @see {@link https://www.charset.org/utf-8 | UTF-8 Charset}\n */\nexport const UTF8_B0_MIN = 32;\n\n/**\n * The minimum value for noninitial bytes of a UTF-8 code point.\n *\n * @see {@link https://en.wikipedia.org/wiki/UTF-8#Encoding | UTF-8 Encoding}\n */\nexport const UTF8_BN_MIN = 128;\n\nexport const UTF8_B0_1B_LEAD = 0b00000000;\nexport const UTF8_BN_LEAD = 0b10000000;\nexport const UTF8_B0_2B_LEAD = 0b11000000;\nexport const UTF8_B0_3B_LEAD = 0b11100000;\nexport const UTF8_B0_4B_LEAD = 0b11110000;\n\nexport const UTF8_B0_1B_LEAD_MASK = 0b10000000;\nexport const UTF8_BN_LEAD_MASK = 0b11000000;\nexport const UTF8_B0_2B_LEAD_MASK = 0b11100000;\nexport const UTF8_B0_3B_LEAD_MASK = 0b11110000;\nexport const UTF8_B0_4B_LEAD_MASK = 0b11111000;\n\nexport const UTF8_B0_1B_MAX = 0b01111111;\nexport const UTF8_BN_MAX = 0b10111111;\nexport const UTF8_B0_2B_MAX = 0b11011111;\nexport const UTF8_B0_3B_MAX = 0b11101111;\nexport const UTF8_B0_4B_MAX = 0b11110111;\nexport const UTF8_B0_MAX = UTF8_B0_4B_MAX;\n\nexport const UTF8_B0_1B_LEN = UTF8_B0_1B_MAX - UTF8_B0_MIN + 1;\nexport const UTF8_B0_2B_LEN = UTF8_B0_2B_MAX - UTF8_B0_MIN + 1;\nexport const UTF8_B0_3B_LEN = UTF8_B0_3B_MAX - UTF8_B0_MIN + 1;\nexport const UTF8_B0_4B_LEN = UTF8_B0_4B_MAX - UTF8_B0_MIN + 1;\nexport const UTF8_B0_LEN = UTF8_B0_MAX - UTF8_B0_MIN + 1;\nexport const UTF8_BN_LEN = UTF8_BN_MAX - UTF8_BN_MIN + 1;\n","import { CHAR_ZERO } from \"./utf8\";\n\n/**\n * The minimum value in bytes for `highWaterMark`.\n */\nexport const HIGH_WATER_MARK_MIN = 16384; // 16KiB\n\n/**\n * The maximum value in bytes for `highWaterMark`.\n */\nexport const HIGH_WATER_MARK_MAX = 1048576; // 1MiB\n\n/**\n * The `highWaterMark` for write streams.\n */\nexport const HIGH_WATER_MARK_OUT = 1048576; // 1MiB\n\n/**\n * The ratio of the file size to use for calculating\n * the `highWaterMark` of a stream.\n */\nexport const HIGH_WATER_MARK_RATIO = 0.000152;\n\n/**\n * The minimum size in bytes of a file chunk.\n */\nexport const CHUNK_SIZE_MIN = HIGH_WATER_MARK_MIN;\n\n// PARSE DOUBLE\n\n/**\n * Used to parse doubles from -9.9 to 9.9.\n */\nexport const CHAR_ZERO_11 = 11 * CHAR_ZERO;\n\n/**\n * Used to parse doubles from -99.9 to 99.9.\n */\nexport const CHAR_ZERO_111 = 111 * CHAR_ZERO;\n","/**\n * The minimum number of web workers (inclusive).\n */\nexport const MIN_WORKERS = 1;\n\n/**\n * The maximum number of web workers (inclusive).\n */\nexport const MAX_WORKERS = 512;\n","import { open } from \"fs/promises\";\n\nimport { CHAR_NEWLINE } from \"../constants/utf8\";\nimport {\n  HIGH_WATER_MARK_MAX,\n  HIGH_WATER_MARK_MIN,\n  HIGH_WATER_MARK_RATIO,\n} from \"../constants/stream\";\n\n/**\n * Clamp a value within a given range.\n *\n * @param value - The value to clamp.\n * @param min - The range min (inclusive).\n * @param max - The range max (inclusive).\n *\n * @returns The clamped value.\n */\nexport function clamp(value: number, min: number, max: number): number {\n  return value > min ? (value <= max ? value : max) : min;\n}\n\n/**\n * Splits a file into `target` chunks or less.\n *\n * - Each chunk is aligned to a file line;\n * i.e. file start, newline ('\\n') or file end.\n * - A chunk's size will be greater than or equal to `fileSize / target`.\n * - `target` chunks or less will be generated.\n *\n * @param filePath - The local path to the file to be chunked.\n * @param target - The target number of chunks to split the file into.\n * @param maxLineLength - The maximum length of a line in the file.\n * @param minSize - The minimum size of a chunk in bytes. Defaults to `0`.\n *\n * @returns A promise that resolves to an array of index pairs, where each\n * pair represents a chunk's start (inclusive) and end (exclusive) indices.\n *\n * @throws Will throw an error if the file cannot be opened or read.\n */\nexport async function getFileChunks(\n  filePath: string,\n  target: number,\n  maxLineLength: number,\n  minSize = 0,\n): Promise<[number, number][]> {\n  // Open the given file\n  const file = await open(filePath);\n  try {\n    // Get the file's size\n    const size = (await file.stat()).size;\n    // Calculate each chunk's target size\n    const chunkSize = Math.max(minSize, Math.floor(size / target));\n    // Initialize constants\n    const buffer = Buffer.allocUnsafe(maxLineLength);\n    const chunks: [number, number][] = [];\n    // Traverse the file, visiting each chunk's end index (exclusive)\n    let start = 0;\n    for (let end = chunkSize; end < size; end += chunkSize) {\n      // Read a line at the intended end index\n      const res = await file.read(buffer, 0, maxLineLength, end);\n      // Find the nearest newline ('\\n') character\n      const newline = buffer.indexOf(CHAR_NEWLINE);\n      // If found\n      if (newline >= 0 && newline < res.bytesRead) {\n        // Align end with the newline\n        end += newline + 1;\n        // Add the chunk\n        chunks.push([start, end]);\n        // Update the start index for the next chunk\n        start = end;\n      }\n    }\n    // Add the last chunk, if necessary\n    if (start < size) {\n      chunks.push([start, size]);\n    }\n    // Return chunks\n    return chunks;\n  } finally {\n    // Always close the file before returning\n    await file.close();\n  }\n}\n\n/**\n * Calculates an optimal highWaterMark value based on the given size.\n *\n * @param size - The size based on which the highWaterMark will be calculated.\n *\n * @returns The calculated highWaterMark value.\n */\nexport function getHighWaterMark(size: number): number {\n  // Get size percentage\n  size *= HIGH_WATER_MARK_RATIO;\n  // Get nearest power\n  size = Math.round(Math.log2(size));\n  // Calculate high water mark\n  size = 2 ** size;\n  // Clamp value\n  return clamp(size, HIGH_WATER_MARK_MIN, HIGH_WATER_MARK_MAX);\n}\n","import { UTF8_B0_2B_LEN } from \"./utf8\";\n\n// Configurable constants\n\n/**\n * The default initial size of a trie.\n */\nexport const TRIE_DEFAULT_SIZE = 524288; // 2 MiB\n\n/**\n * The growth factor for resizing a trie (Approx. Phi)\n */\nexport const TRIE_GROWTH_FACTOR = 1.6180339887;\n\n// Internal trie pointer\n\nexport const TRIE_PTR_IDX_IDX = 0;\nexport const TRIE_PTR_IDX_MEM = 1;\n\nexport const TRIE_PTR_MEM = TRIE_PTR_IDX_MEM;\n\n// Cross-trie pointer (aka redirect)\n\nexport const TRIE_XPTR_ID_IDX = 0;\nexport const TRIE_XPTR_ID_MEM = 1;\n\nexport const TRIE_XPTR_IDX_IDX = 1;\nexport const TRIE_XPTR_IDX_MEM = 1;\n\nexport const TRIE_XPTR_MEM = TRIE_XPTR_ID_MEM + TRIE_XPTR_IDX_MEM;\n\n// Trie node\n\nexport const TRIE_NODE_ID_IDX = 0;\nexport const TRIE_NODE_ID_MEM = 1;\n\nexport const TRIE_NODE_VALUE_IDX = 1;\nexport const TRIE_NODE_VALUE_MEM = 1;\n\nexport const TRIE_NODE_CHILDREN_IDX = 2;\nexport const TRIE_NODE_CHILDREN_LEN = UTF8_B0_2B_LEN;\nexport const TRIE_NODE_CHILDREN_MEM = TRIE_PTR_MEM * TRIE_NODE_CHILDREN_LEN;\n\nexport const TRIE_NODE_MEM =\n  TRIE_NODE_ID_MEM + TRIE_NODE_VALUE_MEM + TRIE_NODE_CHILDREN_MEM;\n\n// Trie\n\n/**\n * Represents a null / undefined trie element.\n */\nexport const TRIE_NULL = 0;\n\nexport const TRIE_SIZE_IDX = 0;\nexport const TRIE_SIZE_MEM = 1;\n\nexport const TRIE_ROOT_IDX = 1;\nexport const TRIE_ROOT_MEM = TRIE_NODE_MEM;\n\nexport const TRIE_ID_IDX = TRIE_ROOT_IDX + TRIE_NODE_ID_IDX;\nexport const TRIE_MEM = TRIE_SIZE_MEM + TRIE_ROOT_MEM;\n","import { WriteStream } from \"node:fs\";\n\nimport {\n  TRIE_DEFAULT_SIZE,\n  TRIE_PTR_MEM,\n  TRIE_PTR_IDX_IDX,\n  TRIE_GROWTH_FACTOR,\n  TRIE_MEM,\n  TRIE_ID_IDX,\n  TRIE_NODE_CHILDREN_IDX,\n  TRIE_NODE_ID_IDX,\n  TRIE_NODE_VALUE_IDX,\n  TRIE_NULL,\n  TRIE_ROOT_IDX,\n  TRIE_SIZE_IDX,\n  TRIE_XPTR_MEM,\n  TRIE_XPTR_IDX_IDX,\n  TRIE_XPTR_ID_IDX,\n  TRIE_NODE_MEM,\n  TRIE_NODE_CHILDREN_MEM,\n  TRIE_NODE_CHILDREN_LEN,\n} from \"../constants/utf8Trie\";\nimport { UTF8_B0_MIN } from \"../constants/utf8\";\n\nexport function add(\n  trie: Int32Array,\n  key: ArrayLike<number>,\n  min: number,\n  max: number,\n): [Int32Array, number] {\n  let index = TRIE_ROOT_IDX;\n  while (min < max) {\n    index += TRIE_NODE_CHILDREN_IDX + TRIE_PTR_MEM * (key[min++] - UTF8_B0_MIN);\n    let child = trie[index + TRIE_PTR_IDX_IDX];\n    if (child === TRIE_NULL) {\n      // Allocate new node\n      child = trie[TRIE_SIZE_IDX];\n      if (child + TRIE_NODE_MEM > trie.length) {\n        trie = grow(trie, child + TRIE_NODE_MEM);\n      }\n      trie[TRIE_SIZE_IDX] += TRIE_NODE_MEM;\n      // Attach and initialize node\n      trie[index + TRIE_PTR_IDX_IDX] = child;\n      trie[child + TRIE_NODE_ID_IDX] = trie[TRIE_ID_IDX];\n    }\n    index = child;\n  }\n\n  return [trie, index];\n}\n\nexport function createTrie(id = 0, size = TRIE_DEFAULT_SIZE): Int32Array {\n  size = Math.max(TRIE_MEM, size);\n  const trie = new Int32Array(new SharedArrayBuffer(size << 2));\n  trie[TRIE_SIZE_IDX] = TRIE_MEM;\n  trie[TRIE_ID_IDX] = id;\n  return trie;\n}\n\nexport function grow(trie: Int32Array, minSize = 0): Int32Array {\n  const length = trie[TRIE_SIZE_IDX];\n  minSize = Math.max(minSize, Math.ceil(length * TRIE_GROWTH_FACTOR));\n  const next = new Int32Array(new SharedArrayBuffer(minSize << 2));\n  for (let i = 0; i < length; ++i) {\n    next[i] = trie[i];\n  }\n  return next;\n}\n\nexport function mergeLeft(\n  tries: Int32Array[],\n  at: number,\n  bt: number,\n  mergeFn: (ai: number, bi: number) => void,\n): void {\n  const queue: [number, number, number, number][] = [\n    [at, TRIE_ROOT_IDX, bt, TRIE_ROOT_IDX],\n  ];\n\n  do {\n    const Q = queue.length;\n    for (let q = 0; q < Q; ++q) {\n      let [at, ai, bt, bi] = queue[q];\n\n      // If right value is not null\n      const bvi = tries[bt][bi + TRIE_NODE_VALUE_IDX];\n      if (bvi !== TRIE_NULL) {\n        // If left value is not null\n        const avi = tries[at][ai + TRIE_NODE_VALUE_IDX];\n        if (avi !== TRIE_NULL) {\n          mergeFn(avi, bvi);\n        } else {\n          tries[at][ai + TRIE_NODE_VALUE_IDX] = bvi;\n        }\n      }\n\n      // Adjust to children property\n      ai += TRIE_NODE_CHILDREN_IDX;\n      bi += TRIE_NODE_CHILDREN_IDX;\n\n      // Traverse right children\n      const bn = bi + TRIE_NODE_CHILDREN_MEM;\n      while (bi < bn) {\n        // If right child is null\n        let ri = tries[bt][bi + TRIE_PTR_IDX_IDX];\n        if (ri === TRIE_NULL) {\n          // Move to next children\n          ai += TRIE_PTR_MEM;\n          bi += TRIE_PTR_MEM;\n          continue;\n        }\n\n        // Resolve right child if redirect\n        const rt = tries[bt][ri + TRIE_NODE_ID_IDX];\n        if (bt !== rt) {\n          ri = tries[bt][ri + TRIE_XPTR_IDX_IDX];\n        }\n\n        // If left child is null\n        let li = tries[at][ai + TRIE_PTR_IDX_IDX];\n        if (li === TRIE_NULL) {\n          // Allocate new redirect in left trie\n          li = tries[at][TRIE_SIZE_IDX];\n          if (li + TRIE_XPTR_MEM > tries[at].length) {\n            tries[at] = grow(tries[at], li + TRIE_XPTR_MEM);\n          }\n          tries[at][TRIE_SIZE_IDX] += TRIE_XPTR_MEM;\n          // Add new redirect\n          tries[at][li + TRIE_XPTR_ID_IDX] = rt;\n          tries[at][li + TRIE_XPTR_IDX_IDX] = ri;\n        } else {\n          // Resolve left child if redirect\n          const lt = tries[at][li + TRIE_NODE_ID_IDX];\n          if (at !== lt) {\n            ai = tries[at][li + TRIE_XPTR_IDX_IDX];\n          }\n          // Merge children\n          queue.push([lt, li, rt, ri]);\n        }\n\n        // Move to next children\n        ai += TRIE_PTR_MEM;\n        bi += TRIE_PTR_MEM;\n      }\n    }\n    queue.splice(0, Q);\n  } while (queue.length > 0);\n}\n\nexport function print(\n  tries: Int32Array[],\n  key: Buffer,\n  trieIndex: number,\n  stream: WriteStream,\n  separator = \"\",\n  callbackFn: (\n    stream: WriteStream,\n    key: Buffer,\n    keyLen: number,\n    valueIndex: number,\n  ) => void,\n): void {\n  const stack: [number, number, number][] = new Array(key.length + 1);\n  stack[0] = [trieIndex, TRIE_ROOT_IDX + TRIE_NODE_CHILDREN_IDX, 0];\n\n  let top = 0;\n  let tail = false;\n  do {\n    let [trieI, childPtr, numChild] = stack[top];\n\n    // Check if end of children array\n    if (numChild >= TRIE_NODE_CHILDREN_LEN) {\n      --top;\n      continue;\n    }\n\n    // Update stack top\n    stack[top][1] += TRIE_PTR_MEM;\n    ++stack[top][2];\n\n    // Check if child exists\n    let childI = tries[trieI][childPtr + TRIE_PTR_IDX_IDX];\n    if (childI === TRIE_NULL) {\n      continue;\n    }\n\n    // Resolve redirect, if any\n    const childTrieI = tries[trieI][childI + TRIE_NODE_ID_IDX];\n    if (trieI !== childTrieI) {\n      childI = tries[trieI][childI + TRIE_XPTR_IDX_IDX];\n      trieI = childTrieI;\n    }\n\n    // Add the child to the stack\n    key[top] = numChild + UTF8_B0_MIN;\n    stack[++top] = [trieI, childI + TRIE_NODE_CHILDREN_IDX, 0];\n\n    // Print value, if any\n    const valueIndex = tries[trieI][childI + TRIE_NODE_VALUE_IDX];\n    if (valueIndex !== TRIE_NULL) {\n      // Print separator if not first value\n      if (tail) {\n        stream.write(separator);\n      }\n      tail = true;\n      callbackFn(stream, key, top, valueIndex);\n    }\n  } while (top >= 0);\n}\n","import { Worker } from \"worker_threads\";\n\n/**\n * Creates a new Worker instance.\n *\n * @param workerPath - The path to the worker script.\n *\n * @returns A new Worker instance.\n */\nexport function createWorker(workerPath: string): Worker {\n  const worker = new Worker(workerPath);\n  worker.on(\"error\", (err) => {\n    throw err;\n  });\n  worker.on(\"messageerror\", (err) => {\n    throw err;\n  });\n  worker.on(\"exit\", (code) => {\n    if (code > 1 || code < 0) {\n      throw new Error(`Worker ${worker.threadId} exited with code ${code}`);\n    }\n  });\n  return worker;\n}\n\n/**\n * Executes a task on a Worker and returns a Promise that resolves with the response.\n *\n * @param worker - The Worker instance to execute the task.\n * @param req - The request to send to the worker.\n *\n * @returns A Promise that resolves with the response from the worker.\n */\nexport function exec<Req, Res>(worker: Worker, req: Req): Promise<Res> {\n  return new Promise<Res>((resolve) => {\n    worker.once(\"message\", resolve);\n    worker.postMessage(req);\n  });\n}\n","import { WriteStream, createWriteStream } from \"node:fs\";\nimport { Worker } from \"node:worker_threads\";\n\nimport type { ProcessRequest } from \"./types/processRequest\";\nimport type { ProcessResponse } from \"./types/processResponse\";\n\nimport {\n  ENTRY_MAX_LEN,\n  MAX_STATIONS,\n  STATION_NAME_MAX_LEN,\n} from \"./constants/constraints\";\nimport { CHUNK_SIZE_MIN, HIGH_WATER_MARK_OUT } from \"./constants/stream\";\nimport { MAX_WORKERS, MIN_WORKERS } from \"./constants/workers\";\nimport { clamp, getFileChunks } from \"./utils/stream\";\nimport { print } from \"./utils/utf8Trie\";\nimport { MergeResponse } from \"./types/mergeResponse\";\nimport { MergeRequest } from \"./types/mergeRequest\";\nimport { createWorker, exec } from \"./utils/worker\";\n\nexport async function run(\n  filePath: string,\n  workerPath: string,\n  maxWorkers: number,\n  outPath = \"\",\n): Promise<void> {\n  // Sanitize number of workers\n  maxWorkers = clamp(maxWorkers, MIN_WORKERS, MAX_WORKERS);\n\n  // Split the file into chunks. Creates 1 or fewer chunks per worker\n  const chunks = await getFileChunks(\n    filePath,\n    maxWorkers,\n    ENTRY_MAX_LEN,\n    CHUNK_SIZE_MIN,\n  );\n\n  // Adjust the number of workers to the number of chunks\n  maxWorkers = chunks.length;\n\n  // Initialize data\n  const valBuf = new SharedArrayBuffer((MAX_STATIONS * maxWorkers + 1) << 4);\n  const mins = new Int16Array(valBuf);\n  const maxes = new Int16Array(valBuf, 2);\n  const counts = new Uint32Array(valBuf, 4);\n  const sums = new Float64Array(valBuf, 8);\n  const tries: Int32Array[] = new Array(maxWorkers);\n\n  // Create workers\n  const workers = new Array<Worker>(maxWorkers);\n  for (let i = 0; i < maxWorkers; ++i) {\n    workers[i] = createWorker(workerPath);\n  }\n\n  // Process each chunk\n  const tasks = new Array<Promise<unknown>>(maxWorkers);\n  for (let i = 0; i < maxWorkers; ++i) {\n    tasks[i] = exec<ProcessRequest, ProcessResponse>(workers[i], {\n      type: \"process_request\",\n      counts,\n      end: chunks[i][1],\n      filePath,\n      id: i,\n      maxes,\n      mins,\n      start: chunks[i][0],\n      sums,\n    }).then((res) => {\n      tries[res.id] = res.trie;\n    });\n  }\n\n  // Merge tries\n  for (let i = tasks.length - 1; i > 0; --i) {\n    const a = (i - 1) >> 1;\n    const b = i;\n    tasks[a] = tasks[a]\n      .then(() => tasks[b])\n      .then(() =>\n        exec<MergeRequest, MergeResponse>(workers[a], {\n          type: \"merge_request\",\n          a,\n          b,\n          counts,\n          maxes,\n          mins,\n          sums,\n          tries,\n        }),\n      )\n      .then((res) => {\n        tries[res.id] = res.trie;\n      });\n  }\n\n  // Terminate workers\n  for (let i = 0; i < maxWorkers; ++i) {\n    tasks[i] = tasks[i].then(() => workers[i].terminate());\n  }\n\n  // Wait for completion\n  await Promise.all(tasks);\n\n  // Print results\n  const out = createWriteStream(outPath, {\n    fd: outPath.length < 1 ? 1 : undefined,\n    flags: \"a\",\n    highWaterMark: HIGH_WATER_MARK_OUT,\n  });\n  const buffer = Buffer.allocUnsafe(STATION_NAME_MAX_LEN);\n  out.write(\"{\");\n  print(tries, buffer, 0, out, \", \", printStation);\n  out.end(\"}\\n\");\n\n  function printStation(\n    stream: WriteStream,\n    name: Buffer,\n    nameLen: number,\n    vi: number,\n  ): void {\n    const avg = Math.round(sums[vi << 1] / counts[vi << 2]);\n    stream.write(name.toString(\"utf8\", 0, nameLen));\n    stream.write(\"=\");\n    stream.write((mins[vi << 3] / 10).toFixed(1));\n    stream.write(\"/\");\n    stream.write((avg / 10).toFixed(1));\n    stream.write(\"/\");\n    stream.write((maxes[vi << 3] / 10).toFixed(1));\n  }\n}\n","import { createReadStream } from \"node:fs\";\n\nimport type { ProcessRequest } from \"./types/processRequest\";\nimport type { ProcessResponse } from \"./types/processResponse\";\n\nimport { CHAR_SEMICOLON } from \"./constants/utf8\";\nimport { CHAR_NEWLINE } from \"./constants/utf8\";\nimport { CHAR_MINUS } from \"./constants/utf8\";\nimport { ENTRY_MAX_LEN, MAX_STATIONS } from \"./constants/constraints\";\nimport { CHAR_ZERO_11, CHAR_ZERO_111 } from \"./constants/stream\";\nimport { TRIE_NODE_VALUE_IDX, TRIE_NULL } from \"./constants/utf8Trie\";\nimport { getHighWaterMark } from \"./utils/stream\";\nimport { add, createTrie, mergeLeft } from \"./utils/utf8Trie\";\nimport { MergeRequest } from \"./types/mergeRequest\";\nimport { MergeResponse } from \"./types/mergeResponse\";\n\nexport async function run({\n  end,\n  filePath,\n  id,\n  start,\n  // Shared memory\n  counts,\n  maxes,\n  mins,\n  sums,\n}: ProcessRequest): Promise<ProcessResponse> {\n  // Check chunk size\n  if (start >= end) {\n    return { type: \"process_response\", id, trie: createTrie(id, 0) };\n  }\n\n  // Initialize constants\n  let trie = createTrie(id);\n  let stations = id * MAX_STATIONS + 1;\n  const buffer = Buffer.allocUnsafe(ENTRY_MAX_LEN);\n\n  // Create the chunk stream\n  const stream = createReadStream(filePath, {\n    start,\n    end: end - 1,\n    highWaterMark: getHighWaterMark(end - start),\n  });\n\n  // For each chunk\n  let bufI = 0;\n  let tempI = 0;\n  let leaf: number;\n  for await (const chunk of stream) {\n    // For each byte\n    const N = chunk.length;\n    for (let i = 0; i < N; ++i) {\n      if (chunk[i] === CHAR_SEMICOLON) {\n        // If semicolon\n        tempI = bufI;\n      } else if (chunk[i] !== CHAR_NEWLINE) {\n        // If not newline\n        buffer[bufI++] = chunk[i];\n      } else {\n        // Get temperature\n        const tempV = parseDouble(buffer, tempI, bufI);\n        bufI = 0;\n        // Add the station's name to the trie and get leaf index\n        [trie, leaf] = add(trie, buffer, 0, tempI);\n        // If the station existed\n        if (trie[leaf + TRIE_NODE_VALUE_IDX] !== TRIE_NULL) {\n          // Update the station's value\n          updateStation(trie[leaf + TRIE_NODE_VALUE_IDX], tempV);\n        } else {\n          // Add the new station's value\n          trie[leaf + TRIE_NODE_VALUE_IDX] = stations;\n          newStation(stations++, tempV);\n        }\n      }\n    }\n  }\n\n  function newStation(index: number, temp: number): void {\n    mins[index << 3] = temp;\n    maxes[index << 3] = temp;\n    counts[index << 2] = 1;\n    sums[index << 1] = temp;\n  }\n\n  function updateStation(index: number, temp: number): void {\n    index <<= 3;\n    mins[index] = mins[index] <= temp ? mins[index] : temp;\n    maxes[index] = maxes[index] >= temp ? maxes[index] : temp;\n    ++counts[index >> 1];\n    sums[index >> 2] += temp;\n  }\n\n  return { type: \"process_response\", id, trie };\n}\n\nexport function parseDouble(b: Buffer, min: number, max: number): number {\n  if (b[min] === CHAR_MINUS) {\n    ++min;\n    return min + 4 > max\n      ? -(10 * b[min] + b[min + 2] - CHAR_ZERO_11)\n      : -(100 * b[min] + 10 * b[min + 1] + b[min + 3] - CHAR_ZERO_111);\n  }\n  return min + 4 > max\n    ? 10 * b[min] + b[min + 2] - CHAR_ZERO_11\n    : 100 * b[min] + 10 * b[min + 1] + b[min + 3] - CHAR_ZERO_111;\n}\n\nexport function merge({\n  a,\n  b,\n  tries,\n  counts,\n  maxes,\n  mins,\n  sums,\n}: MergeRequest): MergeResponse {\n  mergeLeft(tries, a, b, mergeStations);\n  function mergeStations(ai: number, bi: number): void {\n    ai <<= 3;\n    bi <<= 3;\n    mins[ai] = Math.min(mins[ai], mins[bi]);\n    maxes[ai] = Math.max(maxes[ai], maxes[bi]);\n    counts[ai >> 1] += counts[bi >> 1];\n    sums[ai >> 2] += sums[bi >> 2];\n  }\n  return { type: \"merge_response\", id: a, trie: tries[a] };\n}\n","import { availableParallelism } from \"node:os\";\nimport { fileURLToPath } from \"node:url\";\nimport { isMainThread, parentPort } from \"node:worker_threads\";\n\nimport { run as runMain } from \"./main\";\nimport { merge, run as runWorker } from \"./worker\";\nimport { Message } from \"./types/message\";\nimport { ProcessRequest } from \"./types/processRequest\";\nimport { MergeRequest } from \"./types/mergeRequest\";\n\nif (isMainThread) {\n  const workerPath = fileURLToPath(import.meta.url);\n  runMain(process.argv[2], workerPath, availableParallelism());\n} else {\n  parentPort!.addListener(\"message\", async (msg: Message) => {\n    if (msg.type === \"process_request\") {\n      const res = await runWorker(msg as ProcessRequest);\n      parentPort!.postMessage(res);\n    } else if (msg.type === \"merge_request\") {\n      const res = merge(msg as MergeRequest);\n      parentPort!.postMessage(res);\n    } else {\n      throw new Error(\"Unknown message type\");\n    }\n  });\n}\n"],"names":["MAX_STATIONS","STATION_NAME_MAX_LEN","ENTRY_MAX_LEN","CHAR_MINUS","CHAR_NEWLINE","CHAR_SEMICOLON","CHAR_ZERO","UTF8_B0_MIN","UTF8_B0_2B_LEN","HIGH_WATER_MARK_MIN","HIGH_WATER_MARK_MAX","HIGH_WATER_MARK_OUT","HIGH_WATER_MARK_RATIO","CHUNK_SIZE_MIN","CHAR_ZERO_11","CHAR_ZERO_111","MIN_WORKERS","MAX_WORKERS","clamp","value","min","max","getFileChunks","filePath","target","maxLineLength","minSize","file","open","size","chunkSize","buffer","chunks","start","end","res","newline","getHighWaterMark","TRIE_DEFAULT_SIZE","TRIE_GROWTH_FACTOR","TRIE_PTR_IDX_IDX","TRIE_PTR_IDX_MEM","TRIE_PTR_MEM","TRIE_XPTR_ID_IDX","TRIE_XPTR_ID_MEM","TRIE_XPTR_IDX_IDX","TRIE_XPTR_IDX_MEM","TRIE_XPTR_MEM","TRIE_NODE_ID_IDX","TRIE_NODE_ID_MEM","TRIE_NODE_VALUE_IDX","TRIE_NODE_VALUE_MEM","TRIE_NODE_CHILDREN_IDX","TRIE_NODE_CHILDREN_LEN","TRIE_NODE_CHILDREN_MEM","TRIE_NODE_MEM","TRIE_NULL","TRIE_SIZE_IDX","TRIE_SIZE_MEM","TRIE_ROOT_IDX","TRIE_ROOT_MEM","TRIE_ID_IDX","TRIE_MEM","add","trie","key","index","child","grow","createTrie","id","length","next","i","mergeLeft","tries","at","bt","mergeFn","queue","Q","q","ai","bi","bvi","avi","bn","ri","rt","li","lt","print","trieIndex","stream","separator","callbackFn","stack","top","tail","trieI","childPtr","numChild","childI","childTrieI","valueIndex","createWorker","workerPath","worker","Worker","err","code","exec","req","resolve","run","maxWorkers","outPath","valBuf","mins","maxes","counts","sums","workers","tasks","a","b","out","createWriteStream","printStation","name","nameLen","vi","avg","stations","createReadStream","bufI","tempI","leaf","chunk","N","tempV","parseDouble","updateStation","newStation","temp","merge","mergeStations","isMainThread","fileURLToPath","runMain","availableParallelism","parentPort","msg","runWorker"],"mappings":"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"}