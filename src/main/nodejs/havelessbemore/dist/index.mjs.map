{
  "version": 3,
  "sources": ["../src/index.ts", "../src/main.ts", "../src/utils/stream.ts", "../src/utils/utf8Trie.ts", "../src/utils/worker.ts", "../src/worker.ts", "../src/utils/parse.ts"],
  "sourcesContent": ["import { availableParallelism } from \"node:os\";\nimport { fileURLToPath } from \"node:url\";\nimport { isMainThread, parentPort } from \"node:worker_threads\";\n\nimport type { MergeRequest } from \"./types/mergeRequest\";\nimport type { ProcessRequest } from \"./types/processRequest\";\nimport { RequestType, type Request } from \"./types/request\";\n\nimport { run as runMain } from \"./main\";\nimport { merge, run as runWorker } from \"./worker\";\n\nif (isMainThread) {\n  const workerPath = fileURLToPath(import.meta.url);\n  runMain(process.argv[2], workerPath, availableParallelism());\n} else {\n  parentPort!.addListener(\"message\", async (msg: Request) => {\n    if (msg.type === RequestType.PROCESS) {\n      parentPort!.postMessage(await runWorker(msg as ProcessRequest));\n    } else if (msg.type === RequestType.MERGE) {\n      parentPort!.postMessage(merge(msg as MergeRequest));\n    } else {\n      throw new Error(\"Unknown message type\");\n    }\n  });\n}\n", "import { WriteStream, createWriteStream } from \"node:fs\";\nimport { open } from \"node:fs/promises\";\nimport { stdout } from \"node:process\";\n\nimport type { MergeRequest } from \"./types/mergeRequest\";\nimport type { MergeResponse } from \"./types/mergeResponse\";\nimport type { ProcessRequest } from \"./types/processRequest\";\nimport type { ProcessResponse } from \"./types/processResponse\";\n\nimport { BRC } from \"./constants/brc\";\nimport { Config } from \"./constants/config\";\nimport { clamp, getFileChunks } from \"./utils/stream\";\nimport { print } from \"./utils/utf8Trie\";\nimport { createWorker, exec } from \"./utils/worker\";\nimport { RequestType } from \"./types/request\";\n\nexport async function run(\n  filePath: string,\n  workerPath: string,\n  maxWorkers: number,\n  outPath = \"\",\n): Promise<void> {\n  // Sanitize number of workers\n  maxWorkers = clamp(maxWorkers, Config.WORKERS_MIN, Config.WORKERS_MAX);\n\n  // Open the given file\n  const file = await open(filePath, \"r\");\n\n  // Split the file into chunks. Creates 1 or fewer chunks per worker\n  const chunks = await getFileChunks(\n    file,\n    maxWorkers,\n    BRC.MAX_ENTRY_LEN,\n    Config.CHUNK_SIZE_MIN,\n  );\n\n  // Adjust the number of workers to the number of chunks\n  maxWorkers = chunks.length;\n\n  // Initialize data\n  const valBuf = new SharedArrayBuffer(\n    (BRC.MAX_STATIONS * maxWorkers + 1) << 4,\n  );\n  const mins = new Int16Array(valBuf);\n  const maxes = new Int16Array(valBuf, 2);\n  const counts = new Uint32Array(valBuf, 4);\n  const sums = new Float64Array(valBuf, 8);\n  const tries = new Array<Int32Array>(maxWorkers);\n\n  // Run\n  const unmerged: number[] = [];\n  const tasks = new Array<Promise<unknown>>(maxWorkers);\n  for (let i = 0; i < maxWorkers; ++i) {\n    // Create the worker\n    const worker = createWorker(workerPath);\n    // Process the chunk\n    tasks[i] = exec<ProcessRequest, ProcessResponse>(worker, {\n      type: RequestType.PROCESS,\n      counts,\n      end: chunks[i][1],\n      filePath,\n      id: i,\n      maxes,\n      mins,\n      start: chunks[i][0],\n      sums,\n    }).then(async (res) => {\n      // Add result to trie array\n      const a = res.id;\n      tries[res.id] = res.trie;\n      // Merge with other tries\n      while (unmerged.length > 0) {\n        const res = await exec<MergeRequest, MergeResponse>(worker, {\n          type: RequestType.MERGE,\n          a,\n          b: unmerged.pop()!,\n          counts,\n          maxes,\n          mins,\n          sums,\n          tries,\n        });\n        // Update the trie array\n        for (const id of res.ids) {\n          tries[id] = res.tries[id];\n        }\n      }\n      unmerged.push(a);\n      // Stop worker\n      return worker.terminate();\n    });\n  }\n\n  // Wait for completion\n  await Promise.all(tasks);\n\n  // Close the file\n  await file.close();\n\n  // Print results\n  const out = createWriteStream(outPath, {\n    fd: outPath.length < 1 ? stdout.fd : undefined,\n    flags: \"a\",\n    highWaterMark: Config.HIGH_WATER_MARK_OUT,\n  });\n  const buffer = Buffer.allocUnsafe(BRC.MAX_STATION_NAME_LEN);\n  out.write(\"{\");\n  print(tries, buffer, unmerged[0], out, \", \", printStation);\n  out.end(\"}\\n\");\n\n  function printStation(\n    stream: WriteStream,\n    name: Buffer,\n    nameLen: number,\n    vi: number,\n  ): void {\n    const avg = Math.round(sums[vi << 1] / counts[vi << 2]);\n    stream.write(name.toString(\"utf8\", 0, nameLen));\n    stream.write(\"=\");\n    stream.write((mins[vi << 3] / 10).toFixed(1));\n    stream.write(\"/\");\n    stream.write((avg / 10).toFixed(1));\n    stream.write(\"/\");\n    stream.write((maxes[vi << 3] / 10).toFixed(1));\n  }\n}\n", "import { FileHandle } from \"fs/promises\";\n\nimport { Config } from \"../constants/config\";\nimport { CharCode } from \"../constants/utf8\";\n\n/**\n * Clamp a value within a given range.\n *\n * @param value - The value to clamp.\n * @param min - The range min (inclusive).\n * @param max - The range max (inclusive).\n *\n * @returns The clamped value.\n */\nexport function clamp(value: number, min: number, max: number): number {\n  return value > min ? (value <= max ? value : max) : min;\n}\n\n/**\n * Splits a file into `target` chunks or less.\n *\n * - Each chunk is aligned to a file line;\n * i.e. file start, newline ('\\n') or file end.\n * - A chunk's size will be greater than or equal to `fileSize / target`.\n * - `target` chunks or less will be generated.\n *\n * @param filePath - The local path to the file to be chunked.\n * @param target - The target number of chunks to split the file into.\n * @param maxLineLength - The maximum length of a line in the file.\n * @param minSize - The minimum size of a chunk in bytes. Defaults to `0`.\n *\n * @returns A promise that resolves to an array of index pairs, where each\n * pair represents a chunk's start (inclusive) and end (exclusive) indices.\n *\n * @throws Will throw an error if the file cannot be opened or read.\n */\nexport async function getFileChunks(\n  file: FileHandle,\n  target: number,\n  maxLineLength: number,\n  minSize = 0,\n): Promise<[number, number][]> {\n  // Get the file's size\n  const size = (await file.stat()).size;\n  // Calculate each chunk's target size\n  const chunkSize = Math.max(minSize, Math.floor(size / target));\n  // Initialize constants\n  const buffer = Buffer.allocUnsafe(maxLineLength);\n  const chunks: [number, number][] = [];\n  // Traverse the file, visiting each chunk's end index (exclusive)\n  let start = 0;\n  for (let end = chunkSize; end < size; end += chunkSize) {\n    // Read a line at the intended end index\n    const res = await file.read(buffer, 0, maxLineLength, end);\n    // Find the nearest newline ('\\n') character\n    const newline = buffer.indexOf(CharCode.NEWLINE);\n    // If found\n    if (newline >= 0 && newline < res.bytesRead) {\n      // Align end with the newline\n      end += newline + 1;\n      // Add the chunk\n      chunks.push([start, end]);\n      // Update the start index for the next chunk\n      start = end;\n    }\n  }\n  // Add the last chunk, if necessary\n  if (start < size) {\n    chunks.push([start, size]);\n  }\n  // Return chunks\n  return chunks;\n}\n\n/**\n * Calculates an optimal highWaterMark value based on the given size.\n *\n * @param size - The size based on which the highWaterMark will be calculated.\n *\n * @returns The calculated highWaterMark value.\n */\nexport function getHighWaterMark(size: number): number {\n  // Get size percentage\n  size *= Config.HIGH_WATER_MARK_RATIO;\n  // Get nearest power\n  size = Math.round(Math.log2(size));\n  // Calculate high water mark\n  size = 2 ** size;\n  // Clamp value\n  return clamp(size, Config.HIGH_WATER_MARK_MIN, Config.HIGH_WATER_MARK_MAX);\n}\n", "import { WriteStream } from \"node:fs\";\n\nimport {\n  Trie,\n  TrieNodeProto,\n  TrieProto,\n  TriePointerProto,\n  TrieRedirectProto,\n  UTF8,\n} from \"../constants/utf8\";\n\nexport function add(\n  trie: Int32Array,\n  key: ArrayLike<number>,\n  min: number,\n  max: number,\n): [Int32Array, number] {\n  let index: number = TrieProto.ROOT_IDX;\n  while (min < max) {\n    index +=\n      TrieNodeProto.CHILDREN_IDX +\n      TriePointerProto.MEM * (key[min++] - UTF8.BYTE_MIN);\n    let child = trie[index + TriePointerProto.IDX_IDX];\n    if (child === Trie.NULL) {\n      // Allocate node\n      child = trie[TrieProto.SIZE_IDX];\n      if (child + TrieNodeProto.MEM > trie.length) {\n        trie = grow(trie, child + TrieNodeProto.MEM);\n      }\n      trie[TrieProto.SIZE_IDX] += TrieNodeProto.MEM;\n      // Attach node\n      trie[index + TriePointerProto.IDX_IDX] = child;\n      // Initialize node\n      trie[child + TrieNodeProto.ID_IDX] = trie[TrieProto.ID_IDX];\n    }\n    index = child;\n  }\n\n  return [trie, index];\n}\n\nexport function get(\n  tries: Int32Array[],\n  trie: number,\n  key: ArrayLike<number>,\n  min: number,\n  max: number,\n): number | undefined {\n  let node: number = TrieProto.ROOT_IDX;\n  while (min < max) {\n    const ptr =\n      node +\n      TrieNodeProto.CHILDREN_IDX +\n      TriePointerProto.MEM * (key[min++] - UTF8.BYTE_MIN);\n    let child = tries[trie][ptr + TriePointerProto.IDX_IDX];\n    if (child === Trie.NULL) {\n      return undefined;\n    }\n    // Resolve redirect, if any\n    const childTrie = tries[trie][child + TrieNodeProto.ID_IDX];\n    if (childTrie !== trie) {\n      child = tries[trie][child + TrieRedirectProto.IDX_IDX];\n      trie = childTrie;\n    }\n    node = child;\n  }\n  return node;\n}\n\nexport function createTrie(id = 0, size = Trie.DEFAULT_SIZE): Int32Array {\n  size = Math.max(TrieProto.MEM, size);\n  const trie = new Int32Array(new SharedArrayBuffer(size << 2));\n  trie[TrieProto.SIZE_IDX] = TrieProto.MEM;\n  trie[TrieProto.ID_IDX] = id;\n  return trie;\n}\n\nexport function grow(trie: Int32Array, minSize = 0): Int32Array {\n  const length = trie[TrieProto.SIZE_IDX];\n  minSize = Math.max(minSize, Math.ceil(length * Trie.GROWTH_FACTOR));\n  const next = new Int32Array(new SharedArrayBuffer(minSize << 2));\n  for (let i = 0; i < length; ++i) {\n    next[i] = trie[i];\n  }\n  return next;\n}\n\nexport function mergeLeft(\n  tries: Int32Array[],\n  at: number,\n  bt: number,\n  mergeFn: (ai: number, bi: number) => void,\n): number[] {\n  const grown: number[] = [];\n  const queue: [number, number, number, number][] = [\n    [at, TrieProto.ROOT_IDX, bt, TrieProto.ROOT_IDX],\n  ];\n\n  do {\n    const Q = queue.length;\n    for (let q = 0; q < Q; ++q) {\n      // eslint-disable-next-line prefer-const\n      let [at, ai, bt, bi] = queue[q];\n\n      // If right value is not null\n      const bvi = tries[bt][bi + TrieNodeProto.VALUE_IDX];\n      if (bvi !== Trie.NULL) {\n        // If left value is not null\n        const avi = tries[at][ai + TrieNodeProto.VALUE_IDX];\n        if (avi !== Trie.NULL) {\n          mergeFn(avi, bvi);\n        } else {\n          tries[at][ai + TrieNodeProto.VALUE_IDX] = bvi;\n        }\n      }\n\n      // Adjust to children property\n      ai += TrieNodeProto.CHILDREN_IDX;\n      bi += TrieNodeProto.CHILDREN_IDX;\n\n      // Traverse right children\n      const bn = bi + TrieNodeProto.CHILDREN_MEM;\n      while (bi < bn) {\n        // If right child is null\n        let ri = tries[bt][bi + TriePointerProto.IDX_IDX];\n        if (ri !== Trie.NULL) {\n          // Resolve right child if redirect\n          const rt = tries[bt][ri + TrieNodeProto.ID_IDX];\n          if (bt !== rt) {\n            ri = tries[bt][ri + TrieRedirectProto.IDX_IDX];\n          }\n\n          // If left child is null\n          let li = tries[at][ai + TriePointerProto.IDX_IDX];\n          if (li === Trie.NULL) {\n            // Allocate redirect\n            li = tries[at][TrieProto.SIZE_IDX];\n            if (li + TrieRedirectProto.MEM > tries[at].length) {\n              tries[at] = grow(tries[at], li + TrieRedirectProto.MEM);\n              grown.push(at);\n            }\n            tries[at][TrieProto.SIZE_IDX] += TrieRedirectProto.MEM;\n            // Attach redirect\n            tries[at][ai + TriePointerProto.IDX_IDX] = li;\n            // Initialize redirect\n            tries[at][li + TrieRedirectProto.ID_IDX] = rt;\n            tries[at][li + TrieRedirectProto.IDX_IDX] = ri;\n          } else {\n            // Resolve left child if redirect\n            const lt = tries[at][li + TrieNodeProto.ID_IDX];\n            if (at !== lt) {\n              li = tries[at][li + TrieRedirectProto.IDX_IDX];\n            }\n            // Merge children\n            queue.push([lt, li, rt, ri]);\n          }\n        }\n\n        // Move to next children\n        ai += TriePointerProto.MEM;\n        bi += TriePointerProto.MEM;\n      }\n    }\n    queue.splice(0, Q);\n  } while (queue.length > 0);\n  return grown;\n}\n\nexport function print(\n  tries: Int32Array[],\n  key: Buffer,\n  trieIndex: number,\n  stream: WriteStream,\n  separator = \"\",\n  callbackFn: (\n    stream: WriteStream,\n    key: Buffer,\n    keyLen: number,\n    valueIndex: number,\n  ) => void,\n): void {\n  const stack = new Array<[number, number, number]>(key.length + 1);\n  stack[0] = [trieIndex, TrieProto.ROOT_IDX + TrieNodeProto.CHILDREN_IDX, 0];\n\n  let top = 0;\n  let tail = false;\n  do {\n    // eslint-disable-next-line prefer-const\n    let [trieI, childPtr, numChild] = stack[top];\n\n    // Check if end of children array\n    if (numChild >= TrieNodeProto.CHILDREN_LEN) {\n      --top;\n      continue;\n    }\n\n    // Update stack top\n    stack[top][1] += TriePointerProto.MEM;\n    ++stack[top][2];\n\n    // Check if child exists\n    let childI = tries[trieI][childPtr + TriePointerProto.IDX_IDX];\n    if (childI === Trie.NULL) {\n      continue;\n    }\n\n    // Resolve redirect, if any\n    const childTrieI = tries[trieI][childI + TrieNodeProto.ID_IDX];\n    if (trieI !== childTrieI) {\n      childI = tries[trieI][childI + TrieRedirectProto.IDX_IDX];\n      trieI = childTrieI;\n    }\n\n    // Add the child to the stack\n    key[top] = numChild + UTF8.BYTE_MIN;\n    stack[++top] = [trieI, childI + TrieNodeProto.CHILDREN_IDX, 0];\n\n    // Print value, if any\n    const valueIndex = tries[trieI][childI + TrieNodeProto.VALUE_IDX];\n    if (valueIndex !== Trie.NULL) {\n      // Print separator if not first value\n      if (tail) {\n        stream.write(separator);\n      }\n      tail = true;\n      callbackFn(stream, key, top, valueIndex);\n    }\n  } while (top >= 0);\n}\n", "import { Worker } from \"node:worker_threads\";\n\n/**\n * Creates a new Worker instance.\n *\n * @param workerPath - The path to the worker script.\n *\n * @returns A new Worker instance.\n */\nexport function createWorker(workerPath: string): Worker {\n  const worker = new Worker(workerPath);\n  worker.on(\"error\", (err) => {\n    throw err;\n  });\n  worker.on(\"messageerror\", (err) => {\n    throw err;\n  });\n  worker.on(\"exit\", (code) => {\n    if (code > 1 || code < 0) {\n      throw new Error(`Worker ${worker.threadId} exited with code ${code}`);\n    }\n  });\n  return worker;\n}\n\n/**\n * Executes a task on a Worker and returns a Promise that resolves with the response.\n *\n * @param worker - The Worker instance to execute the task.\n * @param req - The request to send to the worker.\n *\n * @returns A Promise that resolves with the response from the worker.\n */\nexport function exec<Req, Res>(worker: Worker, req: Req): Promise<Res> {\n  return new Promise<Res>((resolve) => {\n    worker.once(\"message\", resolve);\n    worker.postMessage(req);\n  });\n}\n", "import { open } from \"fs/promises\";\n\nimport type { MergeRequest } from \"./types/mergeRequest\";\nimport type { MergeResponse } from \"./types/mergeResponse\";\nimport type { ProcessRequest } from \"./types/processRequest\";\nimport type { ProcessResponse } from \"./types/processResponse\";\n\nimport { BRC } from \"./constants/brc\";\nimport { CharCode, Trie, TrieNodeProto } from \"./constants/utf8\";\nimport { parseDouble } from \"./utils/parse\";\nimport { getHighWaterMark } from \"./utils/stream\";\nimport { add, createTrie, mergeLeft } from \"./utils/utf8Trie\";\n\nexport async function run({\n  end,\n  filePath,\n  id,\n  start,\n  // Shared memory\n  counts,\n  maxes,\n  mins,\n  sums,\n}: ProcessRequest): Promise<ProcessResponse> {\n  // Check chunk size\n  if (start >= end) {\n    return { id, trie: createTrie(id, 0) };\n  }\n\n  // Initialize constants\n  let trie = createTrie(id);\n  let stations = id * BRC.MAX_STATIONS + 1;\n\n  const file = await open(filePath, \"r\");\n  const chunkSize = getHighWaterMark(end - start);\n  const chunk = Buffer.allocUnsafe(chunkSize + BRC.MAX_ENTRY_LEN);\n\n  // For each chunk\n  let i = 0;\n  let minI = 0;\n  let leaf: number;\n  while (start < end) {\n    const res = await file.read(chunk, i, chunkSize, start);\n    start += res.bytesRead;\n\n    for (const N = i + res.bytesRead; i < N; ++i) {\n      // If newline\n      if (chunk[i] === CharCode.NEWLINE) {\n\n        // Get semicolon\n        let semI = i - 5;\n        if (chunk[semI] !== CharCode.SEMICOLON) {\n          semI += 1 | (1 + ~(chunk[semI - 1] === CharCode.SEMICOLON));\n        }\n\n        // Get temperature\n        const tempV = parseDouble(chunk, semI + 1, i);\n\n        // Add the station's name to the trie and get leaf index\n        [trie, leaf] = add(trie, chunk, minI, semI);\n        minI = i + 1;\n\n        // If the station existed\n        if (trie[leaf + TrieNodeProto.VALUE_IDX] !== Trie.NULL) {\n          // Update the station's value\n          updateStation(trie[leaf + TrieNodeProto.VALUE_IDX], tempV);\n        } else {\n          // Add the new station's value\n          trie[leaf + TrieNodeProto.VALUE_IDX] = stations;\n          newStation(stations++, tempV);\n        }\n      }\n    }\n    chunk.copyWithin(0, minI, i);\n    i -= minI;\n    minI = 0;\n  }\n\n  function newStation(index: number, temp: number): void {\n    mins[index << 3] = temp;\n    maxes[index << 3] = temp;\n    counts[index << 2] = 1;\n    sums[index << 1] = temp;\n  }\n\n  function updateStation(index: number, temp: number): void {\n    index <<= 3;\n    mins[index] = mins[index] <= temp ? mins[index] : temp;\n    maxes[index] = maxes[index] >= temp ? maxes[index] : temp;\n    ++counts[index >> 1];\n    sums[index >> 2] += temp;\n  }\n\n  await file.close();\n  return { id, trie };\n}\n\nexport function merge({\n  a,\n  b,\n  tries,\n  counts,\n  maxes,\n  mins,\n  sums,\n}: MergeRequest): MergeResponse {\n  function mergeStations(ai: number, bi: number): void {\n    ai <<= 3;\n    bi <<= 3;\n    mins[ai] = Math.min(mins[ai], mins[bi]);\n    maxes[ai] = Math.max(maxes[ai], maxes[bi]);\n    counts[ai >> 1] += counts[bi >> 1];\n    sums[ai >> 2] += sums[bi >> 2];\n  }\n  const ids = mergeLeft(tries, a, b, mergeStations);\n  return { ids, tries };\n}\n", "import { CharCode } from \"../constants/utf8\";\n\nexport const CHAR_ZERO_11 = 11 * CharCode.ZERO;\nexport const CHAR_ZERO_111 = 111 * CharCode.ZERO;\n\n/**\n * Converts an ASCII numeric string into an integer.\n *\n * Fastest.\n */\nexport function parseDouble(b: Buffer, min: number, max: number): number {\n  if (b[min] === CharCode.MINUS) {\n    ++min;\n    return min + 4 > max\n      ? CHAR_ZERO_11 - 10 * b[min] - b[min + 2]\n      : CHAR_ZERO_111 - 100 * b[min] - 10 * b[min + 1] - b[min + 3];\n  }\n  return min + 4 > max\n    ? 10 * b[min] + b[min + 2] - CHAR_ZERO_11\n    : 100 * b[min] + 10 * b[min + 1] + b[min + 3] - CHAR_ZERO_111;\n}\n\n/**\n * Converts an ASCII numeric string into an integer.\n *\n * Second fastest.\n */\nexport function parseDoubleFlat(b: Buffer, min: number, max: number): number {\n  const sign = -(b[min] === CharCode.MINUS);\n  b[min + ~sign] = CharCode.ZERO;\n  return (\n    ((100 * b[max - 4] + 10 * b[max - 3] + b[max - 1] - CHAR_ZERO_111) ^ sign) -\n    sign\n  );\n}\n\n/**\n * Converts an ASCII numeric string into an integer without branching.\n *\n * Inspired by {@link https://github.com/gunnarmorling/1brc/blob/main/src/main/java/dev/morling/onebrc/CalculateAverage_thomaswue.java#L68 | Quan Anh Mai's method}.\n *\n * Slowest.\n */\nexport function parseDoubleQuan(b: Buffer, min: number, max: number): number {\n  b[min - 1] = 0;\n  const sign = -(b[min] === CharCode.MINUS);\n  const signMask = -(min + 4 >= max) & sign & 0xff000000;\n  let v = b.readUint32BE(max - 4) & ~signMask & 0x0f0f000f;\n  v = (v & 0xff000000) * 0x19 + (v & 0x00ff0000) * 0x280 + (v << 22);\n  return ((v >>> 22) ^ sign) - sign;\n}\n"],
  "mappings": "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",
  "names": ["availableParallelism", "fileURLToPath", "isMainThread", "parentPort", "createWriteStream", "open", "stdout", "clamp", "value", "min", "max", "getFileChunks", "file", "target", "maxLineLength", "minSize", "size", "chunkSize", "buffer", "chunks", "start", "end", "res", "newline", "getHighWaterMark", "add", "trie", "key", "min", "max", "index", "child", "grow", "createTrie", "id", "size", "trie", "grow", "minSize", "length", "next", "i", "mergeLeft", "tries", "at", "bt", "mergeFn", "grown", "queue", "Q", "q", "ai", "bi", "bvi", "avi", "bn", "ri", "rt", "li", "lt", "print", "key", "trieIndex", "stream", "separator", "callbackFn", "stack", "top", "tail", "trieI", "childPtr", "numChild", "childI", "childTrieI", "valueIndex", "Worker", "createWorker", "workerPath", "worker", "err", "code", "exec", "req", "resolve", "run", "filePath", "workerPath", "maxWorkers", "outPath", "clamp", "file", "open", "chunks", "getFileChunks", "valBuf", "mins", "maxes", "counts", "sums", "tries", "unmerged", "tasks", "i", "worker", "createWorker", "exec", "res", "a", "id", "out", "createWriteStream", "stdout", "buffer", "print", "printStation", "stream", "name", "nameLen", "vi", "avg", "open", "CHAR_ZERO_11", "CHAR_ZERO_111", "parseDouble", "b", "min", "max", "run", "end", "filePath", "id", "start", "counts", "maxes", "mins", "sums", "createTrie", "trie", "stations", "file", "open", "chunkSize", "getHighWaterMark", "chunk", "i", "minI", "leaf", "res", "N", "semI", "tempV", "parseDouble", "add", "updateStation", "newStation", "index", "temp", "merge", "a", "b", "tries", "mergeStations", "ai", "bi", "mergeLeft", "isMainThread", "workerPath", "fileURLToPath", "run", "availableParallelism", "parentPort", "msg", "merge"]
}
