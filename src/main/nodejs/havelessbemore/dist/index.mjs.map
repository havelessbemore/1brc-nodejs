{
  "version": 3,
  "sources": ["../src/index.ts", "../src/main.ts", "../src/utils/stream.ts", "../src/constants/utf8Trie.ts", "../src/utils/utf8Trie.ts", "../src/utils/worker.ts", "../src/worker.ts", "../src/utils/parse.ts"],
  "sourcesContent": ["import { availableParallelism } from \"node:os\";\nimport { fileURLToPath } from \"node:url\";\nimport { isMainThread, parentPort } from \"node:worker_threads\";\n\nimport type { MergeRequest } from \"./types/mergeRequest\";\nimport type { ProcessRequest } from \"./types/processRequest\";\nimport type { Request } from \"./types/request\";\n\nimport { run as runMain } from \"./main\";\nimport { merge, run as runWorker } from \"./worker\";\n\nif (isMainThread) {\n  const workerPath = fileURLToPath(import.meta.url);\n  runMain(process.argv[2], workerPath, availableParallelism());\n} else {\n  parentPort!.addListener(\"message\", async (msg: Request) => {\n    if (msg.type === \"process\") {\n      parentPort!.postMessage(await runWorker(msg as ProcessRequest));\n    } else if (msg.type === \"merge\") {\n      parentPort!.postMessage(merge(msg as MergeRequest));\n    } else {\n      throw new Error(\"Unknown message type\");\n    }\n  });\n}\n", "import { WriteStream, createWriteStream } from \"node:fs\";\n\nimport type { MergeRequest } from \"./types/mergeRequest\";\nimport type { MergeResponse } from \"./types/mergeResponse\";\nimport type { ProcessRequest } from \"./types/processRequest\";\nimport type { ProcessResponse } from \"./types/processResponse\";\n\nimport { BRC } from \"./constants/brc\";\nimport { Config } from \"./constants/config\";\nimport { clamp, getFileChunks } from \"./utils/stream\";\nimport { print } from \"./utils/utf8Trie\";\nimport { createWorker, exec } from \"./utils/worker\";\n\nexport async function run(\n  filePath: string,\n  workerPath: string,\n  maxWorkers: number,\n  outPath = \"\",\n): Promise<void> {\n  // Sanitize number of workers\n  maxWorkers = clamp(maxWorkers, Config.WORKERS_MIN, Config.WORKERS_MAX);\n\n  // Split the file into chunks. Creates 1 or fewer chunks per worker\n  const chunks = await getFileChunks(\n    filePath,\n    maxWorkers,\n    BRC.MAX_ENTRY_LEN,\n    Config.CHUNK_SIZE_MIN,\n  );\n\n  // Adjust the number of workers to the number of chunks\n  maxWorkers = chunks.length;\n\n  // Initialize data\n  const valBuf = new SharedArrayBuffer(\n    (BRC.MAX_STATIONS * maxWorkers + 1) << 4,\n  );\n  const mins = new Int16Array(valBuf);\n  const maxes = new Int16Array(valBuf, 2);\n  const counts = new Uint32Array(valBuf, 4);\n  const sums = new Float64Array(valBuf, 8);\n  const tries = new Array<Int32Array>(maxWorkers);\n\n  // Run\n  const unmerged: number[] = [];\n  const tasks = new Array<Promise<unknown>>(maxWorkers);\n  for (let i = 0; i < maxWorkers; ++i) {\n    // Create the worker\n    const worker = createWorker(workerPath);\n    // Process the chunk\n    tasks[i] = exec<ProcessRequest, ProcessResponse>(worker, {\n      type: \"process\",\n      counts,\n      end: chunks[i][1],\n      filePath,\n      id: i,\n      maxes,\n      mins,\n      start: chunks[i][0],\n      sums,\n    }).then(async (res) => {\n      // Add result to trie array\n      const a = res.id;\n      tries[res.id] = res.trie;\n      // Merge with other tries\n      while (unmerged.length > 0) {\n        const res = await exec<MergeRequest, MergeResponse>(worker, {\n          type: \"merge\",\n          a,\n          b: unmerged.pop()!,\n          counts,\n          maxes,\n          mins,\n          sums,\n          tries,\n        });\n        // Update the trie array\n        for (const id of res.ids) {\n          tries[id] = res.tries[id];\n        }\n      }\n      unmerged.push(a);\n      // Stop worker\n      return worker.terminate();\n    });\n  }\n\n  // Wait for completion\n  await Promise.all(tasks);\n\n  // Print results\n  const out = createWriteStream(outPath, {\n    fd: outPath.length < 1 ? 1 : undefined,\n    flags: \"a\",\n    highWaterMark: Config.HIGH_WATER_MARK_OUT,\n  });\n  const buffer = Buffer.allocUnsafe(BRC.MAX_STATION_NAME_LEN);\n  out.write(\"{\");\n  print(tries, buffer, unmerged[0], out, \", \", printStation);\n  out.end(\"}\\n\");\n\n  function printStation(\n    stream: WriteStream,\n    name: Buffer,\n    nameLen: number,\n    vi: number,\n  ): void {\n    const avg = Math.round(sums[vi << 1] / counts[vi << 2]);\n    stream.write(name.toString(\"utf8\", 0, nameLen));\n    stream.write(\"=\");\n    stream.write((mins[vi << 3] / 10).toFixed(1));\n    stream.write(\"/\");\n    stream.write((avg / 10).toFixed(1));\n    stream.write(\"/\");\n    stream.write((maxes[vi << 3] / 10).toFixed(1));\n  }\n}\n", "import { open } from \"fs/promises\";\n\nimport { Config } from \"../constants/config\";\nimport { CharCode } from \"../constants/utf8\";\n\n/**\n * Clamp a value within a given range.\n *\n * @param value - The value to clamp.\n * @param min - The range min (inclusive).\n * @param max - The range max (inclusive).\n *\n * @returns The clamped value.\n */\nexport function clamp(value: number, min: number, max: number): number {\n  return value > min ? (value <= max ? value : max) : min;\n}\n\n/**\n * Splits a file into `target` chunks or less.\n *\n * - Each chunk is aligned to a file line;\n * i.e. file start, newline ('\\n') or file end.\n * - A chunk's size will be greater than or equal to `fileSize / target`.\n * - `target` chunks or less will be generated.\n *\n * @param filePath - The local path to the file to be chunked.\n * @param target - The target number of chunks to split the file into.\n * @param maxLineLength - The maximum length of a line in the file.\n * @param minSize - The minimum size of a chunk in bytes. Defaults to `0`.\n *\n * @returns A promise that resolves to an array of index pairs, where each\n * pair represents a chunk's start (inclusive) and end (exclusive) indices.\n *\n * @throws Will throw an error if the file cannot be opened or read.\n */\nexport async function getFileChunks(\n  filePath: string,\n  target: number,\n  maxLineLength: number,\n  minSize = 0,\n): Promise<[number, number][]> {\n  // Open the given file\n  const file = await open(filePath);\n  try {\n    // Get the file's size\n    const size = (await file.stat()).size;\n    // Calculate each chunk's target size\n    const chunkSize = Math.max(minSize, Math.floor(size / target));\n    // Initialize constants\n    const buffer = Buffer.allocUnsafe(maxLineLength);\n    const chunks: [number, number][] = [];\n    // Traverse the file, visiting each chunk's end index (exclusive)\n    let start = 0;\n    for (let end = chunkSize; end < size; end += chunkSize) {\n      // Read a line at the intended end index\n      const res = await file.read(buffer, 0, maxLineLength, end);\n      // Find the nearest newline ('\\n') character\n      const newline = buffer.indexOf(CharCode.NEWLINE);\n      // If found\n      if (newline >= 0 && newline < res.bytesRead) {\n        // Align end with the newline\n        end += newline + 1;\n        // Add the chunk\n        chunks.push([start, end]);\n        // Update the start index for the next chunk\n        start = end;\n      }\n    }\n    // Add the last chunk, if necessary\n    if (start < size) {\n      chunks.push([start, size]);\n    }\n    // Return chunks\n    return chunks;\n  } finally {\n    // Always close the file before returning\n    await file.close();\n  }\n}\n\n/**\n * Calculates an optimal highWaterMark value based on the given size.\n *\n * @param size - The size based on which the highWaterMark will be calculated.\n *\n * @returns The calculated highWaterMark value.\n */\nexport function getHighWaterMark(size: number): number {\n  // Get size percentage\n  size *= Config.HIGH_WATER_MARK_RATIO;\n  // Get nearest power\n  size = Math.round(Math.log2(size));\n  // Calculate high water mark\n  size = 2 ** size;\n  // Clamp value\n  return clamp(size, Config.HIGH_WATER_MARK_MIN, Config.HIGH_WATER_MARK_MAX);\n}\n", "import { UTF8 } from \"./utf8\";\n\nexport const enum Trie {\n  /**\n   * Represents a `null` trie element.\n   */\n  NULL = 0,\n\n  /**\n   * The default initial size of a trie.\n   */\n  DEFAULT_SIZE = 655360, // 2.5 MiB\n\n  /**\n   * The growth factor for resizing a trie.\n   */\n  GROWTH_FACTOR = 1.6180339887, // ~Phi\n}\n\n/**\n * A pointer can point to either a trie node or a trie redirect.\n *\n * They can be differentiated by the destination's ID value:\n *    - If the ID matches the trie's ID, then it's a trie node.\n *    - Otherwise, it's a trie redirect.\n */\nexport const enum TriePointerProto {\n  // The memory location the pointer points to.\n  IDX_IDX = 0,\n  IDX_MEM = 1,\n\n  // Total memory\n  MEM = IDX_MEM,\n}\n\n/**\n * Points to a memory location in a different trie.\n */\nexport const enum TrieRedirectProto {\n  // The different trie's ID.\n  ID_IDX = 0,\n  ID_MEM = 1,\n\n  // The memory location of the trie node in the different trie.\n  IDX_IDX = 1,\n  IDX_MEM = 1,\n\n  // Total memory\n  MEM = ID_MEM + IDX_MEM,\n}\n\nexport const enum TrieNodeProto {\n  // The trie's ID\n  ID_IDX = 0,\n  ID_MEM = 1,\n\n  // The node's value\n  VALUE_IDX = 1,\n  VALUE_MEM = 1,\n\n  // The node's children pointers\n  CHILDREN_IDX = 2,\n  CHILDREN_LEN = UTF8.BYTE_SPAN,\n  CHILDREN_MEM = TriePointerProto.MEM * CHILDREN_LEN,\n\n  // Total memory\n  MEM = ID_MEM + VALUE_MEM + CHILDREN_MEM,\n}\n\nexport const enum TrieProto {\n  // The memory location for the trie's size.\n  SIZE_IDX = 0,\n  SIZE_MEM = 1,\n\n  // The memory location for the trie's root node.\n  ROOT_IDX = 1,\n  ROOT_MEM = TrieNodeProto.MEM,\n\n  // The memory location for the trie's ID (i.e. the root node's trie ID).\n  ID_IDX = ROOT_IDX + TrieNodeProto.ID_IDX,\n\n  // Total memory\n  MEM = SIZE_MEM + ROOT_MEM,\n}\n", "import { WriteStream } from \"node:fs\";\n\nimport { UTF8 } from \"../constants/utf8\";\nimport {\n  Trie,\n  TrieNodeProto,\n  TrieProto,\n  TriePointerProto,\n  TrieRedirectProto,\n} from \"../constants/utf8Trie\";\n\nexport function add(\n  trie: Int32Array,\n  key: ArrayLike<number>,\n  min: number,\n  max: number,\n): [Int32Array, number] {\n  let index: number = TrieProto.ROOT_IDX;\n  while (min < max) {\n    index +=\n      TrieNodeProto.CHILDREN_IDX +\n      TriePointerProto.MEM * (key[min++] - UTF8.BYTE_MIN);\n    let child = trie[index + TriePointerProto.IDX_IDX];\n    if (child === Trie.NULL) {\n      // Allocate node\n      child = trie[TrieProto.SIZE_IDX];\n      if (child + TrieNodeProto.MEM > trie.length) {\n        trie = grow(trie, child + TrieNodeProto.MEM);\n      }\n      trie[TrieProto.SIZE_IDX] += TrieNodeProto.MEM;\n      // Attach node\n      trie[index + TriePointerProto.IDX_IDX] = child;\n      // Initialize node\n      trie[child + TrieNodeProto.ID_IDX] = trie[TrieProto.ID_IDX];\n    }\n    index = child;\n  }\n\n  return [trie, index];\n}\n\nexport function get(\n  tries: Int32Array[],\n  trie: number,\n  key: ArrayLike<number>,\n  min: number,\n  max: number,\n): number | undefined {\n  let node: number = TrieProto.ROOT_IDX;\n  while (min < max) {\n    const ptr =\n      node +\n      TrieNodeProto.CHILDREN_IDX +\n      TriePointerProto.MEM * (key[min++] - UTF8.BYTE_MIN);\n    let child = tries[trie][ptr + TriePointerProto.IDX_IDX];\n    if (child === Trie.NULL) {\n      return undefined;\n    }\n    // Resolve redirect, if any\n    const childTrie = tries[trie][child + TrieNodeProto.ID_IDX];\n    if (childTrie !== trie) {\n      child = tries[trie][child + TrieRedirectProto.IDX_IDX];\n      trie = childTrie;\n    }\n    node = child;\n  }\n  return node;\n}\n\nexport function createTrie(id = 0, size = Trie.DEFAULT_SIZE): Int32Array {\n  size = Math.max(TrieProto.MEM, size);\n  const trie = new Int32Array(new SharedArrayBuffer(size << 2));\n  trie[TrieProto.SIZE_IDX] = TrieProto.MEM;\n  trie[TrieProto.ID_IDX] = id;\n  return trie;\n}\n\nexport function grow(trie: Int32Array, minSize = 0): Int32Array {\n  const length = trie[TrieProto.SIZE_IDX];\n  minSize = Math.max(minSize, Math.ceil(length * Trie.GROWTH_FACTOR));\n  const next = new Int32Array(new SharedArrayBuffer(minSize << 2));\n  for (let i = 0; i < length; ++i) {\n    next[i] = trie[i];\n  }\n  return next;\n}\n\nexport function mergeLeft(\n  tries: Int32Array[],\n  at: number,\n  bt: number,\n  mergeFn: (ai: number, bi: number) => void,\n): number[] {\n  const grown = new Set<number>();\n  const queue: [number, number, number, number][] = [\n    [at, TrieProto.ROOT_IDX, bt, TrieProto.ROOT_IDX],\n  ];\n\n  do {\n    const Q = queue.length;\n    for (let q = 0; q < Q; ++q) {\n      // eslint-disable-next-line prefer-const\n      let [at, ai, bt, bi] = queue[q];\n\n      // If right value is not null\n      const bvi = tries[bt][bi + TrieNodeProto.VALUE_IDX];\n      if (bvi !== Trie.NULL) {\n        // If left value is not null\n        const avi = tries[at][ai + TrieNodeProto.VALUE_IDX];\n        if (avi !== Trie.NULL) {\n          mergeFn(avi, bvi);\n        } else {\n          tries[at][ai + TrieNodeProto.VALUE_IDX] = bvi;\n        }\n      }\n\n      // Adjust to children property\n      ai += TrieNodeProto.CHILDREN_IDX;\n      bi += TrieNodeProto.CHILDREN_IDX;\n\n      // Traverse right children\n      const bn = bi + TrieNodeProto.CHILDREN_MEM;\n      while (bi < bn) {\n        // If right child is null\n        let ri = tries[bt][bi + TriePointerProto.IDX_IDX];\n        if (ri !== Trie.NULL) {\n          // Resolve right child if redirect\n          const rt = tries[bt][ri + TrieNodeProto.ID_IDX];\n          if (bt !== rt) {\n            ri = tries[bt][ri + TrieRedirectProto.IDX_IDX];\n          }\n\n          // If left child is null\n          let li = tries[at][ai + TriePointerProto.IDX_IDX];\n          if (li === Trie.NULL) {\n            // Allocate redirect\n            li = tries[at][TrieProto.SIZE_IDX];\n            if (li + TrieRedirectProto.MEM > tries[at].length) {\n              tries[at] = grow(tries[at], li + TrieRedirectProto.MEM);\n              grown.add(at);\n            }\n            tries[at][TrieProto.SIZE_IDX] += TrieRedirectProto.MEM;\n            // Attach redirect\n            tries[at][ai + TriePointerProto.IDX_IDX] = li;\n            // Initialize redirect\n            tries[at][li + TrieRedirectProto.ID_IDX] = rt;\n            tries[at][li + TrieRedirectProto.IDX_IDX] = ri;\n          } else {\n            // Resolve left child if redirect\n            const lt = tries[at][li + TrieNodeProto.ID_IDX];\n            if (at !== lt) {\n              li = tries[at][li + TrieRedirectProto.IDX_IDX];\n            }\n            // Merge children\n            queue.push([lt, li, rt, ri]);\n          }\n        }\n\n        // Move to next children\n        ai += TriePointerProto.MEM;\n        bi += TriePointerProto.MEM;\n      }\n    }\n    queue.splice(0, Q);\n  } while (queue.length > 0);\n  return Array.from(grown);\n}\n\nexport function print(\n  tries: Int32Array[],\n  key: Buffer,\n  trieIndex: number,\n  stream: WriteStream,\n  separator = \"\",\n  callbackFn: (\n    stream: WriteStream,\n    key: Buffer,\n    keyLen: number,\n    valueIndex: number,\n  ) => void,\n): void {\n  const stack = new Array<[number, number, number]>(key.length + 1);\n  stack[0] = [trieIndex, TrieProto.ROOT_IDX + TrieNodeProto.CHILDREN_IDX, 0];\n\n  let top = 0;\n  let tail = false;\n  do {\n    // eslint-disable-next-line prefer-const\n    let [trieI, childPtr, numChild] = stack[top];\n\n    // Check if end of children array\n    if (numChild >= TrieNodeProto.CHILDREN_LEN) {\n      --top;\n      continue;\n    }\n\n    // Update stack top\n    stack[top][1] += TriePointerProto.MEM;\n    ++stack[top][2];\n\n    // Check if child exists\n    let childI = tries[trieI][childPtr + TriePointerProto.IDX_IDX];\n    if (childI === Trie.NULL) {\n      continue;\n    }\n\n    // Resolve redirect, if any\n    const childTrieI = tries[trieI][childI + TrieNodeProto.ID_IDX];\n    if (trieI !== childTrieI) {\n      childI = tries[trieI][childI + TrieRedirectProto.IDX_IDX];\n      trieI = childTrieI;\n    }\n\n    // Add the child to the stack\n    key[top] = numChild + UTF8.BYTE_MIN;\n    stack[++top] = [trieI, childI + TrieNodeProto.CHILDREN_IDX, 0];\n\n    // Print value, if any\n    const valueIndex = tries[trieI][childI + TrieNodeProto.VALUE_IDX];\n    if (valueIndex !== Trie.NULL) {\n      // Print separator if not first value\n      if (tail) {\n        stream.write(separator);\n      }\n      tail = true;\n      callbackFn(stream, key, top, valueIndex);\n    }\n  } while (top >= 0);\n}\n", "import { Worker } from \"worker_threads\";\n\n/**\n * Creates a new Worker instance.\n *\n * @param workerPath - The path to the worker script.\n *\n * @returns A new Worker instance.\n */\nexport function createWorker(workerPath: string): Worker {\n  const worker = new Worker(workerPath);\n  worker.on(\"error\", (err) => {\n    throw err;\n  });\n  worker.on(\"messageerror\", (err) => {\n    throw err;\n  });\n  worker.on(\"exit\", (code) => {\n    if (code > 1 || code < 0) {\n      throw new Error(`Worker ${worker.threadId} exited with code ${code}`);\n    }\n  });\n  return worker;\n}\n\n/**\n * Executes a task on a Worker and returns a Promise that resolves with the response.\n *\n * @param worker - The Worker instance to execute the task.\n * @param req - The request to send to the worker.\n *\n * @returns A Promise that resolves with the response from the worker.\n */\nexport function exec<Req, Res>(worker: Worker, req: Req): Promise<Res> {\n  return new Promise<Res>((resolve) => {\n    worker.once(\"message\", resolve);\n    worker.postMessage(req);\n  });\n}\n", "import { createReadStream } from \"node:fs\";\n\nimport type { MergeRequest } from \"./types/mergeRequest\";\nimport type { MergeResponse } from \"./types/mergeResponse\";\nimport type { ProcessRequest } from \"./types/processRequest\";\nimport type { ProcessResponse } from \"./types/processResponse\";\n\nimport { BRC } from \"./constants/brc\";\nimport { CharCode } from \"./constants/utf8\";\nimport { Trie, TrieNodeProto } from \"./constants/utf8Trie\";\nimport { parseDouble } from \"./utils/parse\";\nimport { getHighWaterMark } from \"./utils/stream\";\nimport { add, createTrie, mergeLeft } from \"./utils/utf8Trie\";\n\nexport async function run({\n  end,\n  filePath,\n  id,\n  start,\n  // Shared memory\n  counts,\n  maxes,\n  mins,\n  sums,\n}: ProcessRequest): Promise<ProcessResponse> {\n  // Check chunk size\n  if (start >= end) {\n    return { id, trie: createTrie(id, 0) };\n  }\n\n  // Initialize constants\n  let trie = createTrie(id);\n  let stations = id * BRC.MAX_STATIONS + 1;\n  const buffer = Buffer.allocUnsafe(BRC.MAX_ENTRY_LEN);\n\n  // Create the chunk stream\n  const stream = createReadStream(filePath, {\n    start,\n    end: end - 1,\n    highWaterMark: getHighWaterMark(end - start),\n  });\n\n  // For each chunk\n  let bufI = 0;\n  let leaf: number;\n  for await (const chunk of stream) {\n    // For each byte\n    const N = chunk.length;\n    for (let i = 0; i < N; ++i) {\n      // If not newline\n      if (chunk[i] !== CharCode.NEWLINE) {\n        buffer[bufI++] = chunk[i];\n        continue;\n      }\n\n      // Get semicolon\n      let semI = bufI - 4;\n      if (buffer[semI - 2] === CharCode.SEMICOLON) {\n        semI -= 2;\n      } else if (buffer[semI - 1] === CharCode.SEMICOLON) {\n        semI -= 1;\n      }\n\n      // Get temperature\n      const tempV = parseDouble(buffer, semI + 1, bufI);\n      bufI = 0;\n\n      // Add the station's name to the trie and get leaf index\n      [trie, leaf] = add(trie, buffer, 0, semI);\n\n      // If the station existed\n      if (trie[leaf + TrieNodeProto.VALUE_IDX] !== Trie.NULL) {\n        // Update the station's value\n        updateStation(trie[leaf + TrieNodeProto.VALUE_IDX], tempV);\n      } else {\n        // Add the new station's value\n        trie[leaf + TrieNodeProto.VALUE_IDX] = stations;\n        newStation(stations++, tempV);\n      }\n    }\n  }\n\n  function newStation(index: number, temp: number): void {\n    mins[index << 3] = temp;\n    maxes[index << 3] = temp;\n    counts[index << 2] = 1;\n    sums[index << 1] = temp;\n  }\n\n  function updateStation(index: number, temp: number): void {\n    index <<= 3;\n    mins[index] = mins[index] <= temp ? mins[index] : temp;\n    maxes[index] = maxes[index] >= temp ? maxes[index] : temp;\n    ++counts[index >> 1];\n    sums[index >> 2] += temp;\n  }\n\n  return { id, trie };\n}\n\nexport function merge({\n  a,\n  b,\n  tries,\n  counts,\n  maxes,\n  mins,\n  sums,\n}: MergeRequest): MergeResponse {\n  function mergeStations(ai: number, bi: number): void {\n    ai <<= 3;\n    bi <<= 3;\n    mins[ai] = Math.min(mins[ai], mins[bi]);\n    maxes[ai] = Math.max(maxes[ai], maxes[bi]);\n    counts[ai >> 1] += counts[bi >> 1];\n    sums[ai >> 2] += sums[bi >> 2];\n  }\n  const ids = mergeLeft(tries, a, b, mergeStations);\n  return { ids, tries };\n}\n", "import { CharCode } from \"../constants/utf8\";\n\nexport const CHAR_ZERO_11 = 11 * CharCode.ZERO;\nexport const CHAR_ZERO_111 = 111 * CharCode.ZERO;\n\n/**\n * Converts an ASCII numeric string into an integer.\n *\n * Fastest.\n */\nexport function parseDouble(b: Buffer, min: number, max: number): number {\n  if (b[min] === CharCode.MINUS) {\n    ++min;\n    return min + 4 > max\n      ? CHAR_ZERO_11 - 10 * b[min] - b[min + 2]\n      : CHAR_ZERO_111 - 100 * b[min] - 10 * b[min + 1] - b[min + 3];\n  }\n  return min + 4 > max\n    ? 10 * b[min] + b[min + 2] - CHAR_ZERO_11\n    : 100 * b[min] + 10 * b[min + 1] + b[min + 3] - CHAR_ZERO_111;\n}\n\n/**\n * Converts an ASCII numeric string into an integer.\n *\n * Second fastest.\n */\nexport function parseDoubleFlat(b: Buffer, min: number, max: number): number {\n  const sign = -(b[min] === CharCode.MINUS);\n  b[min + ~sign] = CharCode.ZERO;\n  return (\n    ((100 * b[max - 4] + 10 * b[max - 3] + b[max - 1] - CHAR_ZERO_111) ^ sign) -\n    sign\n  );\n}\n\n/**\n * Converts an ASCII numeric string into an integer without branching.\n *\n * Inspired by {@link https://github.com/gunnarmorling/1brc/blob/main/src/main/java/dev/morling/onebrc/CalculateAverage_thomaswue.java#L68 | Quan Anh Mai's method}.\n *\n * Slowest.\n */\nexport function parseDoubleQuan(b: Buffer, min: number, max: number): number {\n  b[min - 1] = 0;\n  const sign = -(b[min] === CharCode.MINUS);\n  const signMask = -(min + 4 >= max) & sign & 0xff000000;\n  let v = b.readUint32BE(max - 4) & ~signMask & 0x0f0f000f;\n  v = (v & 0xff000000) * 0x19 + (v & 0x00ff0000) * 0x280 + (v << 22);\n  return ((v >>> 22) ^ sign) - sign;\n}\n"],
  "mappings": "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",
  "names": ["TrieNodeProto", "TrieProto", "at", "bt", "res", "run", "run"]
}
