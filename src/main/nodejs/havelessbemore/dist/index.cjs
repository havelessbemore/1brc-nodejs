/*!
 * https://github.com/havelessbemore/1brc-nodejs
 *
 * MIT License
 *
 * Copyright (C) 2024-2024 Michael Rojas <dev.michael.rojas@gmail.com> (https://github.com/havelessbemore)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

"use strict";var z=require("node:os"),J=require("node:url"),X=require("node:worker_threads"),P=require("node:fs"),Q=require("fs/promises"),ee=require("worker_threads"),U=typeof document<"u"?document.currentScript:null;const x=1e4,te=100,W=107,re=45,C=10,ne=59,q=48,k=32,se=216,v=16384,ae=1048576,oe=1048576,ie=152e-6,_e=v,F=11*q,b=111*q,ce=1,ue=512;function B(e,t,r){return e>t?e<=r?e:r:t}async function fe(e,t,r,I=0){const _=await Q.open(e);try{const a=(await _.stat()).size,f=Math.max(I,Math.floor(a/t)),u=Buffer.allocUnsafe(r),s=[];let o=0;for(let E=f;E<a;E+=f){const l=await _.read(u,0,r,E),c=u.indexOf(C);c>=0&&c<l.bytesRead&&(E+=c+1,s.push([o,E]),o=E)}return o<a&&s.push([o,a]),s}finally{await _.close()}}function Ee(e){return e*=ie,e=Math.round(Math.log2(e)),e=2**e,B(e,v,ae)}const Ie=655360,Re=1.6180339887,p=0,le=1,g=le,Me=0,Te=1,S=1,de=1,L=Te+de,D=0,he=1,A=1,we=1,N=2,K=se,Z=g*K,H=he+we+Z,h=0,y=0,me=1,O=1,Ae=H,G=O+D,Y=me+Ae;function pe(e,t,r,I){let _=O;for(;r<I;){_+=N+g*(t[r++]-k);let a=e[_+p];a===h&&(a=e[y],a+H>e.length&&(e=V(e,a+H)),e[y]+=H,e[_+p]=a,e[a+D]=e[G]),_=a}return[e,_]}function $(e=0,t=Ie){t=Math.max(Y,t);const r=new Int32Array(new SharedArrayBuffer(t<<2));return r[y]=Y,r[G]=e,r}function V(e,t=0){const r=e[y];t=Math.max(t,Math.ceil(r*Re));const I=new Int32Array(new SharedArrayBuffer(t<<2));for(let _=0;_<r;++_)I[_]=e[_];return I}function ye(e,t,r,I){const _=new Set,a=[[t,O,r,O]];do{const f=a.length;for(let u=0;u<f;++u){let[s,o,E,l]=a[u];const c=e[E][l+A];if(c!==h){const R=e[s][o+A];R!==h?I(R,c):e[s][o+A]=c}o+=N,l+=N;const d=l+Z;for(;l<d;){let R=e[E][l+p];if(R!==h){const w=e[E][R+D];E!==w&&(R=e[E][R+S]);let n=e[s][o+p];if(n===h)n=e[s][y],n+L>e[s].length&&(e[s]=V(e[s],n+L),_.add(s)),e[s][y]+=L,e[s][o+p]=n,e[s][n+Me]=w,e[s][n+S]=R;else{const i=e[s][n+D];s!==i&&(n=e[s][n+S]),a.push([i,n,w,R])}}o+=g,l+=g}}a.splice(0,f)}while(a.length>0);return Array.from(_)}function ge(e,t,r,I,_="",a){const f=new Array(t.length+1);f[0]=[r,O+N,0];let u=0,s=!1;do{let[o,E,l]=f[u];if(l>=K){--u;continue}f[u][1]+=g,++f[u][2];let c=e[o][E+p];if(c===h)continue;const d=e[o][c+D];o!==d&&(c=e[o][c+S],o=d),t[u]=l+k,f[++u]=[o,c+N,0];const R=e[o][c+A];R!==h&&(s&&I.write(_),s=!0,a(I,t,u,R))}while(u>=0)}function De(e){const t=new ee.Worker(e);return t.on("error",r=>{throw r}),t.on("messageerror",r=>{throw r}),t.on("exit",r=>{if(r>1||r<0)throw new Error(`Worker ${t.threadId} exited with code ${r}`)}),t}function j(e,t){return new Promise(r=>{e.once("message",r),e.postMessage(t)})}async function Ne(e,t,r,I=""){r=B(r,ce,ue);const _=await fe(e,r,W,_e);r=_.length;const a=new SharedArrayBuffer(x*r+1<<4),f=new Int16Array(a),u=new Int16Array(a,2),s=new Uint32Array(a,4),o=new Float64Array(a,8),E=new Array(r),l=new Array(r);for(let n=0;n<r;++n)l[n]=De(t);const c=new Array(r);for(let n=0;n<r;++n)c[n]=j(l[n],{type:"process_request",counts:s,end:_[n][1],filePath:e,id:n,maxes:u,mins:f,start:_[n][0],sums:o}).then(i=>{E[i.id]=i.trie});for(let n=c.length-1;n>0;--n){const i=n-1>>1,M=n;c[i]=c[i].then(()=>c[M]).then(()=>j(l[i],{type:"merge_request",a:i,b:M,counts:s,maxes:u,mins:f,sums:o,tries:E})).then(T=>{for(const m of T.ids)E[m]=T.tries[m]})}for(let n=0;n<r;++n)c[n]=c[n].then(()=>l[n].terminate());await Promise.all(c);const d=P.createWriteStream(I,{fd:I.length<1?1:void 0,flags:"a",highWaterMark:oe}),R=Buffer.allocUnsafe(te);d.write("{"),ge(E,R,0,d,", ",w),d.end(`}
`);function w(n,i,M,T){const m=Math.round(o[T<<1]/s[T<<2]);n.write(i.toString("utf8",0,M)),n.write("="),n.write((f[T<<3]/10).toFixed(1)),n.write("/"),n.write((m/10).toFixed(1)),n.write("/"),n.write((u[T<<3]/10).toFixed(1))}}async function Oe({end:e,filePath:t,id:r,start:I,counts:_,maxes:a,mins:f,sums:u}){if(I>=e)return{type:"process_response",id:r,trie:$(r,0)};let s=$(r),o=r*x+1;const E=Buffer.allocUnsafe(W),l=P.createReadStream(t,{start:I,end:e-1,highWaterMark:Ee(e-I)});let c=0,d=0,R;for await(const i of l){const M=i.length;for(let T=0;T<M;++T)if(i[T]===ne)d=c;else if(i[T]!==C)E[c++]=i[T];else{const m=Xe(E,d,c);c=0,[s,R]=pe(s,E,0,d),s[R+A]!==h?n(s[R+A],m):(s[R+A]=o,w(o++,m))}}function w(i,M){f[i<<3]=M,a[i<<3]=M,_[i<<2]=1,u[i<<1]=M}function n(i,M){i<<=3,f[i]=f[i]<=M?f[i]:M,a[i]=a[i]>=M?a[i]:M,++_[i>>1],u[i>>2]+=M}return{type:"process_response",id:r,trie:s}}function Xe(e,t,r){return e[t]===re?(++t,t+4>r?-(10*e[t]+e[t+2]-F):-(100*e[t]+10*e[t+1]+e[t+3]-b)):t+4>r?10*e[t]+e[t+2]-F:100*e[t]+10*e[t+1]+e[t+3]-b}function Se({a:e,b:t,tries:r,counts:I,maxes:_,mins:a,sums:f}){function u(s,o){s<<=3,o<<=3,a[s]=Math.min(a[s],a[o]),_[s]=Math.max(_[s],_[o]),I[s>>1]+=I[o>>1],f[s>>2]+=f[o>>2]}return{type:"merge_response",ids:ye(r,e,t,u),tries:r}}if(X.isMainThread){const e=J.fileURLToPath(typeof document>"u"?require("url").pathToFileURL(__filename).href:U&&U.src||new URL("index.cjs",document.baseURI).href);Ne(process.argv[2],e,z.availableParallelism())}else X.parentPort.addListener("message",async e=>{if(e.type==="process_request"){const t=await Oe(e);X.parentPort.postMessage(t)}else if(e.type==="merge_request"){const t=Se(e);X.parentPort.postMessage(t)}else throw new Error("Unknown message type")});
//# sourceMappingURL=index.cjs.map
