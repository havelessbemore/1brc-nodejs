/*!
 * https://github.com/havelessbemore/1brc-nodejs
 *
 * MIT License
 *
 * Copyright (C) 2024-2024 Michael Rojas <dev.michael.rojas@gmail.com> (https://github.com/havelessbemore)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

"use strict";var j=require("node:os"),z=require("node:url"),N=require("node:worker_threads"),L=require("node:fs"),J=require("fs/promises"),Q=require("worker_threads"),X=typeof document<"u"?document.currentScript:null;const U=1e4,ee=100,x=107,te=45,P=10,C=59,W=48,q=32,re=216,k=16384,ne=1048576,se=1048576,ae=152e-6,oe=k,v=11*W,F=111*W,ie=1,_e=512;function B(e,n,r){return e>n?e<=r?e:r:n}async function ce(e,n,r,l=0){const i=await J.open(e);try{const a=(await i.stat()).size,f=Math.max(l,Math.floor(a/n)),u=Buffer.allocUnsafe(r),s=[];let o=0;for(let c=f;c<a;c+=f){const I=await i.read(u,0,r,c),_=u.indexOf(P);_>=0&&_<I.bytesRead&&(c+=_+1,s.push([o,c]),o=c)}return o<a&&s.push([o,a]),s}finally{await i.close()}}function ue(e){return e*=ae,e=Math.round(Math.log2(e)),e=2**e,B(e,k,ne)}const Ee=655360,fe=1.6180339887,le=1,D=le,Ie=1,O=1,Re=1,H=Ie+Re,Me=0,Te=1,A=1,de=1,p=2,b=re,K=D*b,S=Te+de+K,h=0,y=0,he=1,g=1,we=S,Z=g+Me,G=he+we;function me(e,n,r,l){let i=g;for(;r<l;){i+=p+(n[r++]-q);let a=e[i];a===h&&(a=e[y],a+S>e.length&&(e=$(e,a+S)),e[y]+=S,e[i]=a,e[a]=e[Z]),i=a}return[e,i]}function Y(e=0,n=Ee){n=Math.max(G,n);const r=new Int32Array(new SharedArrayBuffer(n<<2));return r[y]=G,r[Z]=e,r}function $(e,n=0){const r=e[y];n=Math.max(n,Math.ceil(r*fe));const l=new Int32Array(new SharedArrayBuffer(n<<2));for(let i=0;i<r;++i)l[i]=e[i];return l}function Ae(e,n,r,l){const i=new Set,a=[[n,g,r,g]];do{const f=a.length;for(let u=0;u<f;++u){let[s,o,c,I]=a[u];const _=e[c][I+A];if(_!==h){const R=e[s][o+A];R!==h?l(R,_):e[s][o+A]=_}o+=p,I+=p;const T=I+K;for(;I<T;){let R=e[c][I];if(R!==h){const w=e[c][R];c!==w&&(R=e[c][R+O]);let t=e[s][o];if(t===h)t=e[s][y],t+H>e[s].length&&(e[s]=$(e[s],t+H),i.add(s)),e[s][y]+=H,e[s][o]=t,e[s][t]=w,e[s][t+O]=R;else{const E=e[s][t];s!==E&&(t=e[s][t+O]),a.push([E,t,w,R])}}o+=D,I+=D}}a.splice(0,f)}while(a.length>0);return Array.from(i)}function ye(e,n,r,l,i="",a){const f=new Array(n.length+1);f[0]=[r,g+p,0];let u=0,s=!1;do{let[o,c,I]=f[u];if(I>=b){--u;continue}f[u][1]+=D,++f[u][2];let _=e[o][c];if(_===h)continue;const T=e[o][_];o!==T&&(_=e[o][_+O],o=T),n[u]=I+q,f[++u]=[o,_+p,0];const R=e[o][_+A];R!==h&&(s&&l.write(i),s=!0,a(l,n,u,R))}while(u>=0)}function pe(e){const n=new Q.Worker(e);return n.on("error",r=>{throw r}),n.on("messageerror",r=>{throw r}),n.on("exit",r=>{if(r>1||r<0)throw new Error(`Worker ${n.threadId} exited with code ${r}`)}),n}function V(e,n){return new Promise(r=>{e.once("message",r),e.postMessage(n)})}async function ge(e,n,r,l=""){r=B(r,ie,_e);const i=await ce(e,r,x,oe);r=i.length;const a=new SharedArrayBuffer(U*r+1<<4),f=new Int16Array(a),u=new Int16Array(a,2),s=new Uint32Array(a,4),o=new Float64Array(a,8),c=new Array(r),I=new Array(r);for(let t=0;t<r;++t)I[t]=pe(n);const _=new Array(r);for(let t=0;t<r;++t)_[t]=V(I[t],{type:"process_request",counts:s,end:i[t][1],filePath:e,id:t,maxes:u,mins:f,start:i[t][0],sums:o}).then(E=>{c[E.id]=E.trie});for(let t=_.length-1;t>0;--t){const E=t-1>>1,d=t;_[E]=_[E].then(()=>_[d]).then(()=>V(I[E],{type:"merge_request",a:E,b:d,counts:s,maxes:u,mins:f,sums:o,tries:c})).then(M=>{for(const m of M.ids)c[m]=M.tries[m]})}for(let t=0;t<r;++t)_[t]=_[t].then(()=>I[t].terminate());await Promise.all(_);const T=L.createWriteStream(l,{fd:l.length<1?1:void 0,flags:"a",highWaterMark:se}),R=Buffer.allocUnsafe(ee);T.write("{"),ye(c,R,0,T,", ",w),T.end(`}
`);function w(t,E,d,M){const m=Math.round(o[M<<1]/s[M<<2]);t.write(E.toString("utf8",0,d)),t.write("="),t.write((f[M<<3]/10).toFixed(1)),t.write("/"),t.write((m/10).toFixed(1)),t.write("/"),t.write((u[M<<3]/10).toFixed(1))}}async function Ne({end:e,filePath:n,id:r,start:l,counts:i,maxes:a,mins:f,sums:u}){if(l>=e)return{type:"process_response",id:r,trie:Y(r,0)};let s=Y(r),o=r*U+1;const c=Buffer.allocUnsafe(x),I=L.createReadStream(n,{start:l,end:e-1,highWaterMark:ue(e-l)});let _=0,T;for await(const t of I){const E=t.length;for(let d=0;d<E;++d){if(t[d]!==P){c[_++]=t[d];continue}let M=_-4;c[M-2]===C?M-=2:c[M-1]===C&&(M-=1);const m=De(c,M+1,_);_=0,[s,T]=me(s,c,0,M),s[T+A]!==h?w(s[T+A],m):(s[T+A]=o,R(o++,m))}}function R(t,E){f[t<<3]=E,a[t<<3]=E,i[t<<2]=1,u[t<<1]=E}function w(t,E){t<<=3,f[t]=f[t]<=E?f[t]:E,a[t]=a[t]>=E?a[t]:E,++i[t>>1],u[t>>2]+=E}return{type:"process_response",id:r,trie:s}}function De(e,n,r){return e[n]===te?(++n,n+4>r?-(10*e[n]+e[n+2]-v):-(100*e[n]+10*e[n+1]+e[n+3]-F)):n+4>r?10*e[n]+e[n+2]-v:100*e[n]+10*e[n+1]+e[n+3]-F}function Oe({a:e,b:n,tries:r,counts:l,maxes:i,mins:a,sums:f}){function u(s,o){s<<=3,o<<=3,a[s]=Math.min(a[s],a[o]),i[s]=Math.max(i[s],i[o]),l[s>>1]+=l[o>>1],f[s>>2]+=f[o>>2]}return{type:"merge_response",ids:Ae(r,e,n,u),tries:r}}if(N.isMainThread){const e=z.fileURLToPath(typeof document>"u"?require("url").pathToFileURL(__filename).href:X&&X.src||new URL("index.cjs",document.baseURI).href);ge(process.argv[2],e,j.availableParallelism())}else N.parentPort.addListener("message",async e=>{if(e.type==="process_request")N.parentPort.postMessage(await Ne(e));else if(e.type==="merge_request")N.parentPort.postMessage(Oe(e));else throw new Error("Unknown message type")});
//# sourceMappingURL=index.cjs.map
