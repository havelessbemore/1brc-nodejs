/*!
 * https://github.com/havelessbemore/1brc-nodejs
 *
 * MIT License
 *
 * Copyright (C) 2024-2024 Michael Rojas <dev.michael.rojas@gmail.com> (https://github.com/havelessbemore)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

"use strict";var j=require("node:os"),z=require("node:url"),p=require("node:worker_threads"),X=require("node:fs"),J=require("fs/promises"),Q=require("worker_threads"),U=typeof document<"u"?document.currentScript:null;const x=1e4,ee=100,P=107,te=16384,re=1048576,ne=1048576,oe=152e-6,ae=16384,se=1,ie=512,_e=45,W=10,C=59,k=48,v=32,ce=216;function F(e,r,t){return e>r?e<=t?e:t:r}async function ue(e,r,t,f=0){const i=await J.open(e);try{const a=(await i.stat()).size,u=Math.max(f,Math.floor(a/r)),c=Buffer.allocUnsafe(t),o=[];let s=0;for(let _=u;_<a;_+=u){const I=await i.read(c,0,t,_),E=c.indexOf(W);E>=0&&E<I.bytesRead&&(_+=E+1,o.push([s,_]),s=_)}return s<a&&o.push([s,a]),o}finally{await i.close()}}function Ee(e){return e*=oe,e=Math.round(Math.log2(e)),e=2**e,F(e,te,re)}const fe=655360,le=1.6180339887,Ie=1,D=Ie,Re=1,O=1,Me=1,H=Re+Me,Te=0,de=1,m=1,he=1,y=2,B=ce,b=D*B,S=de+he+b,h=0,g=0,we=1,N=1,Ae=S,q=N+Te,K=we+Ae;function me(e,r,t,f){let i=N;for(;t<f;){i+=y+(r[t++]-v);let a=e[i];a===h&&(a=e[g],a+S>e.length&&(e=G(e,a+S)),e[g]+=S,e[i]=a,e[a]=e[q]),i=a}return[e,i]}function Z(e=0,r=fe){r=Math.max(K,r);const t=new Int32Array(new SharedArrayBuffer(r<<2));return t[g]=K,t[q]=e,t}function G(e,r=0){const t=e[g];r=Math.max(r,Math.ceil(t*le));const f=new Int32Array(new SharedArrayBuffer(r<<2));for(let i=0;i<t;++i)f[i]=e[i];return f}function ge(e,r,t,f){const i=new Set,a=[[r,N,t,N]];do{const u=a.length;for(let c=0;c<u;++c){let[o,s,_,I]=a[c];const E=e[_][I+m];if(E!==h){const R=e[o][s+m];R!==h?f(R,E):e[o][s+m]=E}s+=y,I+=y;const T=I+b;for(;I<T;){let R=e[_][I];if(R!==h){const w=e[_][R];_!==w&&(R=e[_][R+O]);let n=e[o][s];if(n===h)n=e[o][g],n+H>e[o].length&&(e[o]=G(e[o],n+H),i.add(o)),e[o][g]+=H,e[o][s]=n,e[o][n]=w,e[o][n+O]=R;else{const l=e[o][n];o!==l&&(n=e[o][n+O]),a.push([l,n,w,R])}}s+=D,I+=D}}a.splice(0,u)}while(a.length>0);return Array.from(i)}function ye(e,r,t,f,i="",a){const u=new Array(r.length+1);u[0]=[t,N+y,0];let c=0,o=!1;do{let[s,_,I]=u[c];if(I>=B){--c;continue}u[c][1]+=D,++u[c][2];let E=e[s][_];if(E===h)continue;const T=e[s][E];s!==T&&(E=e[s][E+O],s=T),r[c]=I+v,u[++c]=[s,E+y,0];const R=e[s][E+m];R!==h&&(o&&f.write(i),o=!0,a(f,r,c,R))}while(c>=0)}function Ne(e){const r=new Q.Worker(e);return r.on("error",t=>{throw t}),r.on("messageerror",t=>{throw t}),r.on("exit",t=>{if(t>1||t<0)throw new Error(`Worker ${r.threadId} exited with code ${t}`)}),r}function Y(e,r){return new Promise(t=>{e.once("message",t),e.postMessage(r)})}async function pe(e,r,t,f=""){t=F(t,se,ie);const i=await ue(e,t,P,ae);t=i.length;const a=new SharedArrayBuffer(x*t+1<<4),u=new Int16Array(a),c=new Int16Array(a,2),o=new Uint32Array(a,4),s=new Float64Array(a,8),_=new Array(t),I=[],E=new Array(t);for(let n=0;n<t;++n){const l=Ne(r);E[n]=Y(l,{type:"process",counts:o,end:i[n][1],filePath:e,id:n,maxes:c,mins:u,start:i[n][0],sums:s}).then(async d=>{const M=d.id;for(_[d.id]=d.trie;I.length>0;){const A=await Y(l,{type:"merge",a:M,b:I.pop(),counts:o,maxes:c,mins:u,sums:s,tries:_});for(const L of A.ids)_[L]=A.tries[L]}return I.push(M),l.terminate()})}await Promise.all(E);const T=X.createWriteStream(f,{fd:f.length<1?1:void 0,flags:"a",highWaterMark:ne}),R=Buffer.allocUnsafe(ee);T.write("{"),ye(_,R,I[0],T,", ",w),T.end(`}
`);function w(n,l,d,M){const A=Math.round(s[M<<1]/o[M<<2]);n.write(l.toString("utf8",0,d)),n.write("="),n.write((u[M<<3]/10).toFixed(1)),n.write("/"),n.write((A/10).toFixed(1)),n.write("/"),n.write((c[M<<3]/10).toFixed(1))}}const $=11*k,V=111*k;function De(e,r,t){return e[r]===_e?(++r,r+4>t?$-10*e[r]-e[r+2]:V-100*e[r]-10*e[r+1]-e[r+3]):r+4>t?10*e[r]+e[r+2]-$:100*e[r]+10*e[r+1]+e[r+3]-V}async function Oe({end:e,filePath:r,id:t,start:f,counts:i,maxes:a,mins:u,sums:c}){if(f>=e)return{id:t,trie:Z(t,0)};let o=Z(t),s=t*x+1;const _=Buffer.allocUnsafe(P),I=X.createReadStream(r,{start:f,end:e-1,highWaterMark:Ee(e-f)});let E=0,T;for await(const n of I){const l=n.length;for(let d=0;d<l;++d){if(n[d]!==W){_[E++]=n[d];continue}let M=E-4;_[M-2]===C?M-=2:_[M-1]===C&&(M-=1);const A=De(_,M+1,E);E=0,[o,T]=me(o,_,0,M),o[T+m]!==h?w(o[T+m],A):(o[T+m]=s,R(s++,A))}}function R(n,l){u[n<<3]=l,a[n<<3]=l,i[n<<2]=1,c[n<<1]=l}function w(n,l){n<<=3,u[n]=u[n]<=l?u[n]:l,a[n]=a[n]>=l?a[n]:l,++i[n>>1],c[n>>2]+=l}return{id:t,trie:o}}function Se({a:e,b:r,tries:t,counts:f,maxes:i,mins:a,sums:u}){function c(o,s){o<<=3,s<<=3,a[o]=Math.min(a[o],a[s]),i[o]=Math.max(i[o],i[s]),f[o>>1]+=f[s>>1],u[o>>2]+=u[s>>2]}return{ids:ge(t,e,r,c),tries:t}}if(p.isMainThread){const e=z.fileURLToPath(typeof document>"u"?require("url").pathToFileURL(__filename).href:U&&U.src||new URL("index.cjs",document.baseURI).href);pe(process.argv[2],e,j.availableParallelism())}else p.parentPort.addListener("message",async e=>{if(e.type==="process")p.parentPort.postMessage(await Oe(e));else if(e.type==="merge")p.parentPort.postMessage(Se(e));else throw new Error("Unknown message type")});
//# sourceMappingURL=index.cjs.map
