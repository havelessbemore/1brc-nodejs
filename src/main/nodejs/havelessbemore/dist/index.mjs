/*!
 * https://github.com/havelessbemore/1brc-nodejs
 *
 * MIT License
 *
 * Copyright (C) 2024-2024 Michael Rojas <dev.michael.rojas@gmail.com> (https://github.com/havelessbemore)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import{availableParallelism as V}from"node:os";import{fileURLToPath as z}from"node:url";import{isMainThread as j,parentPort as H}from"node:worker_threads";import{createWriteStream as q,createReadStream as J}from"node:fs";import{open as Q}from"fs/promises";import{Worker as tt}from"worker_threads";const L=1e4,et=100,x=107,rt=16384,nt=1048576,ot=1048576,at=152e-6,st=16384,it=1,_t=512,ct=45,U=10,W=59,P=48,C=32,Et=216;function F(t,r,e){return t>r?t<=e?t:e:r}async function ft(t,r,e,I=0){const _=await Q(t);try{const o=(await _.stat()).size,u=Math.max(I,Math.floor(o/r)),E=Buffer.allocUnsafe(e),n=[];let a=0;for(let c=u;c<o;c+=u){const l=await _.read(E,0,e,c),f=E.indexOf(U);f>=0&&f<l.bytesRead&&(c+=f+1,n.push([a,c]),a=c)}return a<o&&n.push([a,o]),n}finally{await _.close()}}function ut(t){return t*=at,t=Math.round(Math.log2(t)),t=2**t,F(t,rt,nt)}const It=655360,lt=1.6180339887,Rt=1,D=Rt,Mt=1,O=1,Tt=1,X=Mt+Tt,mt=0,ht=1,d=1,wt=1,N=2,k=Et,B=D*k,S=ht+wt+B,w=0,g=0,At=1,y=1,dt=S,K=y+mt,Z=At+dt;function gt(t,r,e,I){let _=y;for(;e<I;){_+=N+(r[e++]-C);let o=t[_];o===w&&(o=t[g],o+S>t.length&&(t=G(t,o+S)),t[g]+=S,t[_]=o,t[o]=t[K]),_=o}return[t,_]}function b(t=0,r=It){r=Math.max(Z,r);const e=new Int32Array(new SharedArrayBuffer(r<<2));return e[g]=Z,e[K]=t,e}function G(t,r=0){const e=t[g];r=Math.max(r,Math.ceil(e*lt));const I=new Int32Array(new SharedArrayBuffer(r<<2));for(let _=0;_<e;++_)I[_]=t[_];return I}function Nt(t,r,e,I){const _=new Set,o=[[r,y,e,y]];do{const u=o.length;for(let E=0;E<u;++E){let[n,a,c,l]=o[E];const f=t[c][l+d];if(f!==w){const R=t[n][a+d];R!==w?I(R,f):t[n][a+d]=f}a+=N,l+=N;const T=l+B;for(;l<T;){let R=t[c][l];if(R!==w){const A=t[c][R];c!==A&&(R=t[c][R+O]);let s=t[n][a];if(s===w)s=t[n][g],s+X>t[n].length&&(t[n]=G(t[n],s+X),_.add(n)),t[n][g]+=X,t[n][a]=s,t[n][s]=A,t[n][s+O]=R;else{const i=t[n][s];n!==i&&(s=t[n][s+O]),o.push([i,s,A,R])}}a+=D,l+=D}}o.splice(0,u)}while(o.length>0);return Array.from(_)}function yt(t,r,e,I,_="",o){const u=new Array(r.length+1);u[0]=[e,y+N,0];let E=0,n=!1;do{let[a,c,l]=u[E];if(l>=k){--E;continue}u[E][1]+=D,++u[E][2];let f=t[a][c];if(f===w)continue;const T=t[a][f];a!==T&&(f=t[a][f+O],a=T),r[E]=l+C,u[++E]=[a,f+N,0];const R=t[a][f+d];R!==w&&(n&&I.write(_),n=!0,o(I,r,E,R))}while(E>=0)}function pt(t){const r=new tt(t);return r.on("error",e=>{throw e}),r.on("messageerror",e=>{throw e}),r.on("exit",e=>{if(e>1||e<0)throw new Error(`Worker ${r.threadId} exited with code ${e}`)}),r}function v(t,r){return new Promise(e=>{t.once("message",e),t.postMessage(r)})}async function Dt(t,r,e,I=""){e=F(e,it,_t);const _=await ft(t,e,x,st);e=_.length;const o=new SharedArrayBuffer(L*e+1<<4),u=new Int16Array(o),E=new Int16Array(o,2),n=new Uint32Array(o,4),a=new Float64Array(o,8),c=new Array(e),l=[],f=new Array(e),T=new Array(e);for(let i=0;i<e;++i)f[i]=pt(r),T[i]=v(f[i],{type:"process",counts:n,end:_[i][1],filePath:t,id:i,maxes:E,mins:u,start:_[i][0],sums:a}).then(async m=>{const M=m.id;for(c[m.id]=m.trie;l.length>0;){const h=await v(f[M],{type:"merge",a:M,b:l.pop(),counts:n,maxes:E,mins:u,sums:a,tries:c});for(const p of h.ids)c[p]=h.tries[p]}return l.push(M),f[M].terminate()});await Promise.all(T);const R=q(I,{fd:I.length<1?1:void 0,flags:"a",highWaterMark:ot}),A=Buffer.allocUnsafe(et);R.write("{"),yt(c,A,l[0],R,", ",s),R.end(`}
`);function s(i,m,M,h){const p=Math.round(a[h<<1]/n[h<<2]);i.write(m.toString("utf8",0,M)),i.write("="),i.write((u[h<<3]/10).toFixed(1)),i.write("/"),i.write((p/10).toFixed(1)),i.write("/"),i.write((E[h<<3]/10).toFixed(1))}}const Y=11*P,$=111*P;function Ot(t,r,e){return t[r]===ct?(++r,r+4>e?Y-10*t[r]-t[r+2]:$-100*t[r]-10*t[r+1]-t[r+3]):r+4>e?10*t[r]+t[r+2]-Y:100*t[r]+10*t[r+1]+t[r+3]-$}async function St({end:t,filePath:r,id:e,start:I,counts:_,maxes:o,mins:u,sums:E}){if(I>=t)return{id:e,trie:b(e,0)};let n=b(e),a=e*L+1;const c=Buffer.allocUnsafe(x),l=J(r,{start:I,end:t-1,highWaterMark:ut(t-I)});let f=0,T;for await(const s of l){const i=s.length;for(let m=0;m<i;++m){if(s[m]!==U){c[f++]=s[m];continue}let M=f-4;c[M-2]===W?M-=2:c[M-1]===W&&(M-=1);const h=Ot(c,M+1,f);f=0,[n,T]=gt(n,c,0,M),n[T+d]!==w?A(n[T+d],h):(n[T+d]=a,R(a++,h))}}function R(s,i){u[s<<3]=i,o[s<<3]=i,_[s<<2]=1,E[s<<1]=i}function A(s,i){s<<=3,u[s]=u[s]<=i?u[s]:i,o[s]=o[s]>=i?o[s]:i,++_[s>>1],E[s>>2]+=i}return{id:e,trie:n}}function Ht({a:t,b:r,tries:e,counts:I,maxes:_,mins:o,sums:u}){function E(n,a){n<<=3,a<<=3,o[n]=Math.min(o[n],o[a]),_[n]=Math.max(_[n],_[a]),I[n>>1]+=I[a>>1],u[n>>2]+=u[a>>2]}return{ids:Nt(e,t,r,E),tries:e}}if(j){const t=z(import.meta.url);Dt(process.argv[2],t,V())}else H.addListener("message",async t=>{if(t.type==="process")H.postMessage(await St(t));else if(t.type==="merge")H.postMessage(Ht(t));else throw new Error("Unknown message type")});
//# sourceMappingURL=index.mjs.map
