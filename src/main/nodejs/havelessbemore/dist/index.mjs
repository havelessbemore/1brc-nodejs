/*!
 * https://github.com/havelessbemore/1brc-nodejs
 *
 * MIT License
 *
 * Copyright (C) 2024-2024 Michael Rojas <dev.michael.rojas@gmail.com> (https://github.com/havelessbemore)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import{availableParallelism as V}from"node:os";import{fileURLToPath as z}from"node:url";import{isMainThread as j,parentPort as S}from"node:worker_threads";import{createWriteStream as J,createReadStream as Q}from"node:fs";import{open as ee}from"fs/promises";import{Worker as te}from"worker_threads";const P=1e4,re=100,x=107,ne=45,U=10,se=59,W=48,C=32,oe=216,F=16384,ae=1048576,ie=1048576,_e=152e-6,ce=F,b=11*W,k=111*W,Ee=1,fe=512;function B(e,r,t){return e>r?e<=t?e:t:r}async function Ie(e,r,t,R=0){const _=await ee(e);try{const o=(await _.stat()).size,f=Math.max(R,Math.floor(o/r)),E=Buffer.allocUnsafe(t),s=[];let a=0;for(let I=f;I<o;I+=f){const u=await _.read(E,0,t,I),c=E.indexOf(U);c>=0&&c<u.bytesRead&&(I+=c+1,s.push([a,I]),a=I)}return a<o&&s.push([a,o]),s}finally{await _.close()}}function Re(e){return e*=_e,e=Math.round(Math.log2(e)),e=2**e,B(e,F,ae)}const le=655360,ue=1.6180339887,p=0,Me=1,D=Me,Te=0,me=1,X=1,he=1,L=me+he,N=0,we=1,d=1,Ae=1,y=2,K=oe,Z=D*K,H=we+Ae+Z,h=0,g=0,de=1,O=1,pe=H,G=O+N,q=de+pe;function ge(e,r,t,R){let _=O;for(;t<R;){_+=y+D*(r[t++]-C);let o=e[_+p];o===h&&(o=e[g],o+H>e.length&&(e=Y(e,o+H)),e[g]+=H,e[_+p]=o,e[o+N]=e[G]),_=o}return[e,_]}function v(e=0,r=le){r=Math.max(q,r);const t=new Int32Array(new SharedArrayBuffer(r<<2));return t[g]=q,t[G]=e,t}function Y(e,r=0){const t=e[g];r=Math.max(r,Math.ceil(t*ue));const R=new Int32Array(new SharedArrayBuffer(r<<2));for(let _=0;_<t;++_)R[_]=e[_];return R}function De(e,r,t,R){const _=new Set,o=[[r,O,t,O]];do{const f=o.length;for(let E=0;E<f;++E){let[s,a,I,u]=o[E];const c=e[I][u+d];if(c!==h){const l=e[s][a+d];l!==h?R(l,c):e[s][a+d]=c}a+=y,u+=y;const m=u+Z;for(;u<m;){let l=e[I][u+p];if(l!==h){const w=e[I][l+N];I!==w&&(l=e[I][l+X]);let n=e[s][a+p];if(n===h)n=e[s][g],n+L>e[s].length&&(e[s]=Y(e[s],n+L),_.add(s)),e[s][g]+=L,e[s][a+p]=n,e[s][n+Te]=w,e[s][n+X]=l;else{const i=e[s][n+N];s!==i&&(n=e[s][n+X]),o.push([i,n,w,l])}}a+=D,u+=D}}o.splice(0,f)}while(o.length>0);return Array.from(_)}function Ne(e,r,t,R,_="",o){const f=new Array(r.length+1);f[0]=[t,O+y,0];let E=0,s=!1;do{let[a,I,u]=f[E];if(u>=K){--E;continue}f[E][1]+=D,++f[E][2];let c=e[a][I+p];if(c===h)continue;const m=e[a][c+N];a!==m&&(c=e[a][c+X],a=m),r[E]=u+C,f[++E]=[a,c+y,0];const l=e[a][c+d];l!==h&&(s&&R.write(_),s=!0,o(R,r,E,l))}while(E>=0)}function ye(e){const r=new te(e);return r.on("error",t=>{throw t}),r.on("messageerror",t=>{throw t}),r.on("exit",t=>{if(t>1||t<0)throw new Error(`Worker ${r.threadId} exited with code ${t}`)}),r}function $(e,r){return new Promise(t=>{e.once("message",t),e.postMessage(r)})}async function Oe(e,r,t,R=""){t=B(t,Ee,fe);const _=await Ie(e,t,x,ce);t=_.length;const o=new SharedArrayBuffer(P*t+1<<4),f=new Int16Array(o),E=new Int16Array(o,2),s=new Uint32Array(o,4),a=new Float64Array(o,8),I=new Array(t),u=new Array(t);for(let n=0;n<t;++n)u[n]=ye(r);const c=new Array(t);for(let n=0;n<t;++n)c[n]=$(u[n],{type:"process_request",counts:s,end:_[n][1],filePath:e,id:n,maxes:E,mins:f,start:_[n][0],sums:a}).then(i=>{I[i.id]=i.trie});for(let n=c.length-1;n>0;--n){const i=n-1>>1,M=n;c[i]=c[i].then(()=>c[M]).then(()=>$(u[i],{type:"merge_request",a:i,b:M,counts:s,maxes:E,mins:f,sums:a,tries:I})).then(T=>{for(const A of T.ids)I[A]=T.tries[A]})}for(let n=0;n<t;++n)c[n]=c[n].then(()=>u[n].terminate());await Promise.all(c);const m=J(R,{fd:R.length<1?1:void 0,flags:"a",highWaterMark:ie}),l=Buffer.allocUnsafe(re);m.write("{"),Ne(I,l,0,m,", ",w),m.end(`}
`);function w(n,i,M,T){const A=Math.round(a[T<<1]/s[T<<2]);n.write(i.toString("utf8",0,M)),n.write("="),n.write((f[T<<3]/10).toFixed(1)),n.write("/"),n.write((A/10).toFixed(1)),n.write("/"),n.write((E[T<<3]/10).toFixed(1))}}async function Xe({end:e,filePath:r,id:t,start:R,counts:_,maxes:o,mins:f,sums:E}){if(R>=e)return{type:"process_response",id:t,trie:v(t,0)};let s=v(t),a=t*P+1;const I=Buffer.allocUnsafe(x),u=Q(r,{start:R,end:e-1,highWaterMark:Re(e-R)});let c=0,m=0,l;for await(const i of u){const M=i.length;for(let T=0;T<M;++T)if(i[T]===se)m=c;else if(i[T]!==U)I[c++]=i[T];else{const A=He(I,m,c);c=0,[s,l]=ge(s,I,0,m),s[l+d]!==h?n(s[l+d],A):(s[l+d]=a,w(a++,A))}}function w(i,M){f[i<<3]=M,o[i<<3]=M,_[i<<2]=1,E[i<<1]=M}function n(i,M){i<<=3,f[i]=f[i]<=M?f[i]:M,o[i]=o[i]>=M?o[i]:M,++_[i>>1],E[i>>2]+=M}return{type:"process_response",id:t,trie:s}}function He(e,r,t){return e[r]===ne?(++r,r+4>t?-(10*e[r]+e[r+2]-b):-(100*e[r]+10*e[r+1]+e[r+3]-k)):r+4>t?10*e[r]+e[r+2]-b:100*e[r]+10*e[r+1]+e[r+3]-k}function Se({a:e,b:r,tries:t,counts:R,maxes:_,mins:o,sums:f}){function E(s,a){s<<=3,a<<=3,o[s]=Math.min(o[s],o[a]),_[s]=Math.max(_[s],_[a]),R[s>>1]+=R[a>>1],f[s>>2]+=f[a>>2]}return{type:"merge_response",ids:De(t,e,r,E),tries:t}}if(j){const e=z(import.meta.url);Oe(process.argv[2],e,V())}else S.addListener("message",async e=>{if(e.type==="process_request")S.postMessage(await Xe(e));else if(e.type==="merge_request")S.postMessage(Se(e));else throw new Error("Unknown message type")});
//# sourceMappingURL=index.mjs.map
