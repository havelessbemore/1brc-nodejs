/*!
 * https://github.com/havelessbemore/1brc-nodejs
 *
 * MIT License
 *
 * Copyright (C) 2024-2024 Michael Rojas <dev.michael.rojas@gmail.com> (https://github.com/havelessbemore)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import{availableParallelism as V}from"node:os";import{fileURLToPath as z}from"node:url";import{isMainThread as j,parentPort as S}from"node:worker_threads";import{createWriteStream as q,createReadStream as J}from"node:fs";import{open as Q}from"fs/promises";import{Worker as tt}from"worker_threads";const L=1e4,et=100,x=107,rt=16384,nt=1048576,ot=1048576,at=152e-6,st=16384,it=1,_t=512,ct=45,U=10,W=59,P=48,C=32,Et=216;function F(t,r,e){return t>r?t<=e?t:e:r}async function ft(t,r,e,u=0){const i=await Q(t);try{const a=(await i.stat()).size,E=Math.max(u,Math.floor(a/r)),c=Buffer.allocUnsafe(e),o=[];let s=0;for(let _=E;_<a;_+=E){const l=await i.read(c,0,e,_),f=c.indexOf(U);f>=0&&f<l.bytesRead&&(_+=f+1,o.push([s,_]),s=_)}return s<a&&o.push([s,a]),o}finally{await i.close()}}function ut(t){return t*=at,t=Math.round(Math.log2(t)),t=2**t,F(t,rt,nt)}const It=655360,lt=1.6180339887,Rt=1,y=Rt,Mt=1,D=1,Tt=1,H=Mt+Tt,mt=0,ht=1,d=1,wt=1,N=2,k=Et,B=y*k,O=ht+wt+B,h=0,g=0,At=1,p=1,dt=O,K=p+mt,Z=At+dt;function gt(t,r,e,u){let i=p;for(;e<u;){i+=N+(r[e++]-C);let a=t[i];a===h&&(a=t[g],a+O>t.length&&(t=G(t,a+O)),t[g]+=O,t[i]=a,t[a]=t[K]),i=a}return[t,i]}function b(t=0,r=It){r=Math.max(Z,r);const e=new Int32Array(new SharedArrayBuffer(r<<2));return e[g]=Z,e[K]=t,e}function G(t,r=0){const e=t[g];r=Math.max(r,Math.ceil(e*lt));const u=new Int32Array(new SharedArrayBuffer(r<<2));for(let i=0;i<e;++i)u[i]=t[i];return u}function Nt(t,r,e,u){const i=new Set,a=[[r,p,e,p]];do{const E=a.length;for(let c=0;c<E;++c){let[o,s,_,l]=a[c];const f=t[_][l+d];if(f!==h){const R=t[o][s+d];R!==h?u(R,f):t[o][s+d]=f}s+=N,l+=N;const T=l+B;for(;l<T;){let R=t[_][l];if(R!==h){const w=t[_][R];_!==w&&(R=t[_][R+D]);let n=t[o][s];if(n===h)n=t[o][g],n+H>t[o].length&&(t[o]=G(t[o],n+H),i.add(o)),t[o][g]+=H,t[o][s]=n,t[o][n]=w,t[o][n+D]=R;else{const I=t[o][n];o!==I&&(n=t[o][n+D]),a.push([I,n,w,R])}}s+=y,l+=y}}a.splice(0,E)}while(a.length>0);return Array.from(i)}function pt(t,r,e,u,i="",a){const E=new Array(r.length+1);E[0]=[e,p+N,0];let c=0,o=!1;do{let[s,_,l]=E[c];if(l>=k){--c;continue}E[c][1]+=y,++E[c][2];let f=t[s][_];if(f===h)continue;const T=t[s][f];s!==T&&(f=t[s][f+D],s=T),r[c]=l+C,E[++c]=[s,f+N,0];const R=t[s][f+d];R!==h&&(o&&u.write(i),o=!0,a(u,r,c,R))}while(c>=0)}function yt(t){const r=new tt(t);return r.on("error",e=>{throw e}),r.on("messageerror",e=>{throw e}),r.on("exit",e=>{if(e>1||e<0)throw new Error(`Worker ${r.threadId} exited with code ${e}`)}),r}function v(t,r){return new Promise(e=>{t.once("message",e),t.postMessage(r)})}async function Dt(t,r,e,u=""){e=F(e,it,_t);const i=await ft(t,e,x,st);e=i.length;const a=new SharedArrayBuffer(L*e+1<<4),E=new Int16Array(a),c=new Int16Array(a,2),o=new Uint32Array(a,4),s=new Float64Array(a,8),_=new Array(e),l=[],f=new Array(e);for(let n=0;n<e;++n){const I=yt(r);f[n]=v(I,{type:"process",counts:o,end:i[n][1],filePath:t,id:n,maxes:c,mins:E,start:i[n][0],sums:s}).then(async m=>{const M=m.id;for(_[m.id]=m.trie;l.length>0;){const A=await v(I,{type:"merge",a:M,b:l.pop(),counts:o,maxes:c,mins:E,sums:s,tries:_});for(const X of A.ids)_[X]=A.tries[X]}return l.push(M),I.terminate()})}await Promise.all(f);const T=q(u,{fd:u.length<1?1:void 0,flags:"a",highWaterMark:ot}),R=Buffer.allocUnsafe(et);T.write("{"),pt(_,R,l[0],T,", ",w),T.end(`}
`);function w(n,I,m,M){const A=Math.round(s[M<<1]/o[M<<2]);n.write(I.toString("utf8",0,m)),n.write("="),n.write((E[M<<3]/10).toFixed(1)),n.write("/"),n.write((A/10).toFixed(1)),n.write("/"),n.write((c[M<<3]/10).toFixed(1))}}const Y=11*P,$=111*P;function Ot(t,r,e){return t[r]===ct?(++r,r+4>e?Y-10*t[r]-t[r+2]:$-100*t[r]-10*t[r+1]-t[r+3]):r+4>e?10*t[r]+t[r+2]-Y:100*t[r]+10*t[r+1]+t[r+3]-$}async function St({end:t,filePath:r,id:e,start:u,counts:i,maxes:a,mins:E,sums:c}){if(u>=t)return{id:e,trie:b(e,0)};let o=b(e),s=e*L+1;const _=Buffer.allocUnsafe(x),l=J(r,{start:u,end:t-1,highWaterMark:ut(t-u)});let f=0,T;for await(const n of l){const I=n.length;for(let m=0;m<I;++m){if(n[m]!==U){_[f++]=n[m];continue}let M=f-4;_[M-2]===W?M-=2:_[M-1]===W&&(M-=1);const A=Ot(_,M+1,f);f=0,[o,T]=gt(o,_,0,M),o[T+d]!==h?w(o[T+d],A):(o[T+d]=s,R(s++,A))}}function R(n,I){E[n<<3]=I,a[n<<3]=I,i[n<<2]=1,c[n<<1]=I}function w(n,I){n<<=3,E[n]=E[n]<=I?E[n]:I,a[n]=a[n]>=I?a[n]:I,++i[n>>1],c[n>>2]+=I}return{id:e,trie:o}}function Ht({a:t,b:r,tries:e,counts:u,maxes:i,mins:a,sums:E}){function c(o,s){o<<=3,s<<=3,a[o]=Math.min(a[o],a[s]),i[o]=Math.max(i[o],i[s]),u[o>>1]+=u[s>>1],E[o>>2]+=E[s>>2]}return{ids:Nt(e,t,r,c),tries:e}}if(j){const t=z(import.meta.url);Dt(process.argv[2],t,V())}else S.addListener("message",async t=>{if(t.type==="process")S.postMessage(await St(t));else if(t.type==="merge")S.postMessage(Ht(t));else throw new Error("Unknown message type")});
//# sourceMappingURL=index.mjs.map
