{"version":3,"file":"index.cjs","sources":["../src/constants/constraints.ts","../src/constants/stream.ts","../src/constants/workers.ts","../src/constants/utf8.ts","../src/utils/stream.ts","../src/constants/utf8Trie.ts","../src/utils/utf8Trie.ts","../src/utils/worker.ts","../src/main.ts","../src/utils/parse.ts","../src/worker.ts","../src/index.ts"],"sourcesContent":["/**\n * The maximum number of entries.\n *\n * @remarks\n *\n * Changing this value affects the `count` and\n * `sum` values used for calculating a station's\n * average temperature.\n *\n * Valid values `v` satisfy the following constraints:\n * - Integers where `0 < v < 2^32`\n * - log2(`v` * 10^({@link TEMPERATURE_MAX_LEN}-2)) < 48\n */\nexport const MAX_ENTRIES = 1e9;\n\n/**\n * The maximum number of unique stations.\n *\n * @remarks\n *\n * Changing this value affects the indexing of trie nodes.\n *\n * Valid values `v` satisfy the following constraints:\n * - Positive integer\n * - `v` * {@link STATION_NAME_MAX_LEN} < 3,314,018.\n */\nexport const MAX_STATIONS = 1e4;\n\n/**\n * The maximum byte length of a station name.\n *\n * @remarks\n *\n * Changing this value affects the indexing of trie nodes.\n *\n * Valid values `v` satisfy the following constraints:\n * - Positive integer\n * - {@link MAX_STATIONS} * `v` < 3,314,018.\n */\nexport const STATION_NAME_MAX_LEN = 100;\n\n/**\n * The maximum byte length of a temperature reading.\n *\n * @remarks\n *\n * Changing this value affects the `min`, `max` and `sum` values\n * used for calculating a station's min, max and avg\n * temperatures, respectively.\n *\n * Valid values `v` satisfy the following constraints:\n * - Positive integer\n * - `2 <= v <= 16`.\n *\n * Please note that valid temperatures `t` should be:\n * - `-(10^(v-2)) < t < 10^(v-2)`.\n */\nexport const TEMPERATURE_MAX_LEN = 5;\n\n/**\n * The maximum length in bytes of an entry.\n *\n * Example: `Abha;71.3`\n * - Station name: 1-100 bytes\n * - Semicolon: 1 byte\n * - Temperature: 3-5 bytes\n * - Newline: 1 byte\n */\nexport const ENTRY_MAX_LEN = STATION_NAME_MAX_LEN + TEMPERATURE_MAX_LEN + 2;\n","/**\n * The minimum value in bytes for `highWaterMark`.\n */\nexport const HIGH_WATER_MARK_MIN = 16384; // 16KiB\n\n/**\n * The maximum value in bytes for `highWaterMark`.\n */\nexport const HIGH_WATER_MARK_MAX = 1048576; // 1MiB\n\n/**\n * The `highWaterMark` for write streams.\n */\nexport const HIGH_WATER_MARK_OUT = 1048576; // 1MiB\n\n/**\n * The ratio of the file size to use for calculating\n * the `highWaterMark` of a stream.\n */\nexport const HIGH_WATER_MARK_RATIO = 0.000152;\n\n/**\n * The minimum size in bytes of a file chunk.\n */\nexport const CHUNK_SIZE_MIN = HIGH_WATER_MARK_MIN;\n","/**\n * The minimum number of web workers (inclusive).\n */\nexport const MIN_WORKERS = 1;\n\n/**\n * The maximum number of web workers (inclusive).\n *\n * The purpose is to limit the amount of memory used,\n * since each worker uses its own memory for processing.\n *\n * @remarks\n *\n * This limit should be sufficient for most use cases.\n * However, feel free to adjust up or down as needed.\n *\n * There is not much basis for the current value.\n * Development was done with at most 8 workers and\n * a reasonable input file, with memory never exceeding\n * 20 MiB total across all workers.\n *\n * In theory, the challenge constraints allow for input\n * files that would require each worker using upwards of\n * 800 MiB; 10K stations with completely unique 100 byte names,\n * thus 1M trie nodes of ~0.85 KB each. This should be\n * considered when increasing the number of workers.\n */\nexport const MAX_WORKERS = 512;\n","// UTF-8 char codes\n\n/**\n * The char code for a minus sign: -\n */\nexport const CHAR_MINUS = 45; // \"-\".charCodeAt(0);\n\n/**\n * The char code for a newline: \\n\n */\nexport const CHAR_NEWLINE = 10; // \"\\n\".charCodeAt(0);\n\n/**\n * The char code for a period: .\n */\nexport const CHAR_PERIOD = 46; // \".\".charCodeAt(0);\n\n/**\n * The char code for a semicolon: ;\n */\nexport const CHAR_SEMICOLON = 59; // \";\".charCodeAt(0);\n\n/**\n * The char code for a zero: 0\n */\nexport const CHAR_ZERO = 48; // \"0\".charCodeAt(0);\n\n// UTF-8 constants\n\n/**\n * The minimum value of a UTF-8 byte.\n *\n * Ignores C0 control codes from U+0000 to U+001F.\n *\n * @see {@link https://en.wikipedia.org/wiki/Unicode_control_characters#Category_%22Cc%22_control_codes_(C0_and_C1) | Control Codes}\n */\nexport const UTF8_BYTE_MIN = 32;\n\n/**\n * The maximum value of a UTF-8 byte.\n *\n * @see {@link https://en.wikipedia.org/wiki/UTF-8#Encoding | UTF-8 Encoding}\n */\nexport const UTF8_BYTE_MAX = 0b11110111;\n\n/**\n * The number of possible values in a UTF-8 byte.\n */\nexport const UTF8_BYTE_SPAN = UTF8_BYTE_MAX - UTF8_BYTE_MIN + 1;\n\n/*\nexport const UTF8_B0_1B_LEAD = 0b00000000;\nexport const UTF8_BN_LEAD = 0b10000000;\nexport const UTF8_B0_2B_LEAD = 0b11000000;\nexport const UTF8_B0_3B_LEAD = 0b11100000;\nexport const UTF8_B0_4B_LEAD = 0b11110000;\n\nexport const UTF8_B0_1B_LEAD_MASK = 0b10000000;\nexport const UTF8_BN_LEAD_MASK = 0b11000000;\nexport const UTF8_B0_2B_LEAD_MASK = 0b11100000;\nexport const UTF8_B0_3B_LEAD_MASK = 0b11110000;\nexport const UTF8_B0_4B_LEAD_MASK = 0b11111000;\n\nexport const UTF8_B0_1B_MAX = 0b01111111;\nexport const UTF8_BN_MAX = 0b10111111;\nexport const UTF8_B0_2B_MAX = 0b11011111;\nexport const UTF8_B0_3B_MAX = 0b11101111;\nexport const UTF8_B0_4B_MAX = 0b11110111;\n*/\n","import { open } from \"fs/promises\";\n\nimport { CHAR_NEWLINE } from \"../constants/utf8\";\nimport {\n  HIGH_WATER_MARK_MAX,\n  HIGH_WATER_MARK_MIN,\n  HIGH_WATER_MARK_RATIO,\n} from \"../constants/stream\";\n\n/**\n * Clamp a value within a given range.\n *\n * @param value - The value to clamp.\n * @param min - The range min (inclusive).\n * @param max - The range max (inclusive).\n *\n * @returns The clamped value.\n */\nexport function clamp(value: number, min: number, max: number): number {\n  return value > min ? (value <= max ? value : max) : min;\n}\n\n/**\n * Splits a file into `target` chunks or less.\n *\n * - Each chunk is aligned to a file line;\n * i.e. file start, newline ('\\n') or file end.\n * - A chunk's size will be greater than or equal to `fileSize / target`.\n * - `target` chunks or less will be generated.\n *\n * @param filePath - The local path to the file to be chunked.\n * @param target - The target number of chunks to split the file into.\n * @param maxLineLength - The maximum length of a line in the file.\n * @param minSize - The minimum size of a chunk in bytes. Defaults to `0`.\n *\n * @returns A promise that resolves to an array of index pairs, where each\n * pair represents a chunk's start (inclusive) and end (exclusive) indices.\n *\n * @throws Will throw an error if the file cannot be opened or read.\n */\nexport async function getFileChunks(\n  filePath: string,\n  target: number,\n  maxLineLength: number,\n  minSize = 0,\n): Promise<[number, number][]> {\n  // Open the given file\n  const file = await open(filePath);\n  try {\n    // Get the file's size\n    const size = (await file.stat()).size;\n    // Calculate each chunk's target size\n    const chunkSize = Math.max(minSize, Math.floor(size / target));\n    // Initialize constants\n    const buffer = Buffer.allocUnsafe(maxLineLength);\n    const chunks: [number, number][] = [];\n    // Traverse the file, visiting each chunk's end index (exclusive)\n    let start = 0;\n    for (let end = chunkSize; end < size; end += chunkSize) {\n      // Read a line at the intended end index\n      const res = await file.read(buffer, 0, maxLineLength, end);\n      // Find the nearest newline ('\\n') character\n      const newline = buffer.indexOf(CHAR_NEWLINE);\n      // If found\n      if (newline >= 0 && newline < res.bytesRead) {\n        // Align end with the newline\n        end += newline + 1;\n        // Add the chunk\n        chunks.push([start, end]);\n        // Update the start index for the next chunk\n        start = end;\n      }\n    }\n    // Add the last chunk, if necessary\n    if (start < size) {\n      chunks.push([start, size]);\n    }\n    // Return chunks\n    return chunks;\n  } finally {\n    // Always close the file before returning\n    await file.close();\n  }\n}\n\n/**\n * Calculates an optimal highWaterMark value based on the given size.\n *\n * @param size - The size based on which the highWaterMark will be calculated.\n *\n * @returns The calculated highWaterMark value.\n */\nexport function getHighWaterMark(size: number): number {\n  // Get size percentage\n  size *= HIGH_WATER_MARK_RATIO;\n  // Get nearest power\n  size = Math.round(Math.log2(size));\n  // Calculate high water mark\n  size = 2 ** size;\n  // Clamp value\n  return clamp(size, HIGH_WATER_MARK_MIN, HIGH_WATER_MARK_MAX);\n}\n","import { UTF8_BYTE_SPAN } from \"./utf8\";\n\n// Configurable constants.\n//\n// Controls trie behavior such as the default\n// allocated size and the growth factor when resizing.\n\n/**\n * The default initial size of a trie.\n */\nexport const TRIE_DEFAULT_SIZE = 655360; // 2.5 MiB\n\n/**\n * The growth factor for resizing a trie (Approx. Phi)\n */\nexport const TRIE_GROWTH_FACTOR = 1.6180339887;\n\n// Trie pointer\n//\n// A pointer can point to either a trie node or a trie redirect.\n// They can be differentiated by the destination's ID value:\n//    - If the ID matches the trie's ID, then it's a trie node.\n//    - Otherwise, it's a trie redirect.\n\n// The memory location the pointer points to.\nexport const TRIE_PTR_IDX_IDX = 0;\nexport const TRIE_PTR_IDX_MEM = 1;\n\nexport const TRIE_PTR_MEM = TRIE_PTR_IDX_MEM;\n\n// Trie redirect (aka cross-trie pointer)\n//\n// Points to a memory location in a different trie.\n\n// The different trie's ID.\nexport const TRIE_XPTR_ID_IDX = 0;\nexport const TRIE_XPTR_ID_MEM = 1;\n\n// The memory location of the trie node in the different trie.\nexport const TRIE_XPTR_IDX_IDX = 1;\nexport const TRIE_XPTR_IDX_MEM = 1;\n\nexport const TRIE_XPTR_MEM = TRIE_XPTR_ID_MEM + TRIE_XPTR_IDX_MEM;\n\n// Trie node\n\n// The trie's ID\nexport const TRIE_NODE_ID_IDX = 0;\nexport const TRIE_NODE_ID_MEM = 1;\n\n// The node's value\nexport const TRIE_NODE_VALUE_IDX = 1;\nexport const TRIE_NODE_VALUE_MEM = 1;\n\n// The node's children pointers\nexport const TRIE_NODE_CHILDREN_IDX = 2;\nexport const TRIE_NODE_CHILDREN_LEN = UTF8_BYTE_SPAN;\nexport const TRIE_NODE_CHILDREN_MEM = TRIE_PTR_MEM * TRIE_NODE_CHILDREN_LEN;\n\nexport const TRIE_NODE_MEM =\n  TRIE_NODE_ID_MEM + TRIE_NODE_VALUE_MEM + TRIE_NODE_CHILDREN_MEM;\n\n// Trie\n\n/**\n * Represents a `null` trie element.\n */\nexport const TRIE_NULL = 0;\n\n// The memory location for the trie's size.\nexport const TRIE_SIZE_IDX = 0;\nexport const TRIE_SIZE_MEM = 1;\n\n// The memory location for the trie's root node.\nexport const TRIE_ROOT_IDX = 1;\nexport const TRIE_ROOT_MEM = TRIE_NODE_MEM;\n\n// The memory location for the trie's ID (i.e. the root node's trie ID).\nexport const TRIE_ID_IDX = TRIE_ROOT_IDX + TRIE_NODE_ID_IDX;\n\nexport const TRIE_MEM = TRIE_SIZE_MEM + TRIE_ROOT_MEM;\n","import { WriteStream } from \"node:fs\";\n\nimport {\n  TRIE_DEFAULT_SIZE,\n  TRIE_PTR_MEM,\n  TRIE_GROWTH_FACTOR,\n  TRIE_MEM,\n  TRIE_ID_IDX,\n  TRIE_NODE_CHILDREN_IDX,\n  TRIE_NODE_VALUE_IDX,\n  TRIE_NULL,\n  TRIE_ROOT_IDX,\n  TRIE_SIZE_IDX,\n  TRIE_XPTR_MEM,\n  TRIE_XPTR_IDX_IDX,\n  TRIE_NODE_MEM,\n  TRIE_NODE_CHILDREN_MEM,\n  TRIE_NODE_CHILDREN_LEN,\n} from \"../constants/utf8Trie\";\nimport { UTF8_BYTE_MIN } from \"../constants/utf8\";\n\nexport function add(\n  trie: Int32Array,\n  key: ArrayLike<number>,\n  min: number,\n  max: number,\n): [Int32Array, number] {\n  let index = TRIE_ROOT_IDX;\n  while (min < max) {\n    index +=\n      TRIE_NODE_CHILDREN_IDX + /*TRIE_PTR_MEM * */ (key[min++] - UTF8_BYTE_MIN);\n    let child = trie[index /*+ TRIE_PTR_IDX_IDX*/];\n    if (child === TRIE_NULL) {\n      // Allocate node\n      child = trie[TRIE_SIZE_IDX];\n      if (child + TRIE_NODE_MEM > trie.length) {\n        trie = grow(trie, child + TRIE_NODE_MEM);\n      }\n      trie[TRIE_SIZE_IDX] += TRIE_NODE_MEM;\n      // Attach node\n      trie[index /*+ TRIE_PTR_IDX_IDX*/] = child;\n      // Initialize node\n      trie[child /* + TRIE_NODE_ID_IDX*/] = trie[TRIE_ID_IDX];\n    }\n    index = child;\n  }\n\n  return [trie, index];\n}\n\nexport function get(\n  tries: Int32Array[],\n  trie: number,\n  key: ArrayLike<number>,\n  min: number,\n  max: number,\n): number | undefined {\n  let node = TRIE_ROOT_IDX;\n  while (min < max) {\n    const ptr =\n      node +\n      TRIE_NODE_CHILDREN_IDX +\n      /*TRIE_PTR_MEM * */ (key[min++] - UTF8_BYTE_MIN);\n    let child = tries[trie][ptr /* + TRIE_PTR_IDX_IDX*/];\n    if (child === TRIE_NULL) {\n      return undefined;\n    }\n    // Resolve redirect, if any\n    const childTrie = tries[trie][child /* + TRIE_NODE_ID_IDX*/];\n    if (childTrie !== trie) {\n      child = tries[trie][child + TRIE_XPTR_IDX_IDX];\n      trie = childTrie;\n    }\n    node = child;\n  }\n  return node;\n}\n\nexport function createTrie(id = 0, size = TRIE_DEFAULT_SIZE): Int32Array {\n  size = Math.max(TRIE_MEM, size);\n  const trie = new Int32Array(new SharedArrayBuffer(size << 2));\n  trie[TRIE_SIZE_IDX] = TRIE_MEM;\n  trie[TRIE_ID_IDX] = id;\n  return trie;\n}\n\nexport function grow(trie: Int32Array, minSize = 0): Int32Array {\n  const length = trie[TRIE_SIZE_IDX];\n  minSize = Math.max(minSize, Math.ceil(length * TRIE_GROWTH_FACTOR));\n  const next = new Int32Array(new SharedArrayBuffer(minSize << 2));\n  for (let i = 0; i < length; ++i) {\n    next[i] = trie[i];\n  }\n  return next;\n}\n\nexport function mergeLeft(\n  tries: Int32Array[],\n  at: number,\n  bt: number,\n  mergeFn: (ai: number, bi: number) => void,\n): number[] {\n  const grown = new Set<number>();\n  const queue: [number, number, number, number][] = [\n    [at, TRIE_ROOT_IDX, bt, TRIE_ROOT_IDX],\n  ];\n\n  do {\n    const Q = queue.length;\n    for (let q = 0; q < Q; ++q) {\n      // eslint-disable-next-line prefer-const\n      let [at, ai, bt, bi] = queue[q];\n\n      // If right value is not null\n      const bvi = tries[bt][bi + TRIE_NODE_VALUE_IDX];\n      if (bvi !== TRIE_NULL) {\n        // If left value is not null\n        const avi = tries[at][ai + TRIE_NODE_VALUE_IDX];\n        if (avi !== TRIE_NULL) {\n          mergeFn(avi, bvi);\n        } else {\n          tries[at][ai + TRIE_NODE_VALUE_IDX] = bvi;\n        }\n      }\n\n      // Adjust to children property\n      ai += TRIE_NODE_CHILDREN_IDX;\n      bi += TRIE_NODE_CHILDREN_IDX;\n\n      // Traverse right children\n      const bn = bi + TRIE_NODE_CHILDREN_MEM;\n      while (bi < bn) {\n        // If right child is null\n        let ri = tries[bt][bi /* + TRIE_PTR_IDX_IDX*/];\n        if (ri !== TRIE_NULL) {\n          // Resolve right child if redirect\n          const rt = tries[bt][ri /*+ TRIE_NODE_ID_IDX*/];\n          if (bt !== rt) {\n            ri = tries[bt][ri + TRIE_XPTR_IDX_IDX];\n          }\n\n          // If left child is null\n          let li = tries[at][ai /*+ TRIE_PTR_IDX_IDX*/];\n          if (li === TRIE_NULL) {\n            // Allocate redirect\n            li = tries[at][TRIE_SIZE_IDX];\n            if (li + TRIE_XPTR_MEM > tries[at].length) {\n              tries[at] = grow(tries[at], li + TRIE_XPTR_MEM);\n              grown.add(at);\n            }\n            tries[at][TRIE_SIZE_IDX] += TRIE_XPTR_MEM;\n            // Attach redirect\n            tries[at][ai /*+ TRIE_PTR_IDX_IDX*/] = li;\n            // Initialize redirect\n            tries[at][li /* + TRIE_XPTR_ID_IDX*/] = rt;\n            tries[at][li + TRIE_XPTR_IDX_IDX] = ri;\n          } else {\n            // Resolve left child if redirect\n            const lt = tries[at][li /* + TRIE_NODE_ID_IDX*/];\n            if (at !== lt) {\n              li = tries[at][li + TRIE_XPTR_IDX_IDX];\n            }\n            // Merge children\n            queue.push([lt, li, rt, ri]);\n          }\n        }\n\n        // Move to next children\n        ai += TRIE_PTR_MEM;\n        bi += TRIE_PTR_MEM;\n      }\n    }\n    queue.splice(0, Q);\n  } while (queue.length > 0);\n  return Array.from(grown);\n}\n\nexport function print(\n  tries: Int32Array[],\n  key: Buffer,\n  trieIndex: number,\n  stream: WriteStream,\n  separator = \"\",\n  callbackFn: (\n    stream: WriteStream,\n    key: Buffer,\n    keyLen: number,\n    valueIndex: number,\n  ) => void,\n): void {\n  const stack = new Array<[number, number, number]>(key.length + 1);\n  stack[0] = [trieIndex, TRIE_ROOT_IDX + TRIE_NODE_CHILDREN_IDX, 0];\n\n  let top = 0;\n  let tail = false;\n  do {\n    // eslint-disable-next-line prefer-const\n    let [trieI, childPtr, numChild] = stack[top];\n\n    // Check if end of children array\n    if (numChild >= TRIE_NODE_CHILDREN_LEN) {\n      --top;\n      continue;\n    }\n\n    // Update stack top\n    stack[top][1] += TRIE_PTR_MEM;\n    ++stack[top][2];\n\n    // Check if child exists\n    let childI = tries[trieI][childPtr /* + TRIE_PTR_IDX_IDX*/];\n    if (childI === TRIE_NULL) {\n      continue;\n    }\n\n    // Resolve redirect, if any\n    const childTrieI = tries[trieI][childI /* + TRIE_NODE_ID_IDX*/];\n    if (trieI !== childTrieI) {\n      childI = tries[trieI][childI + TRIE_XPTR_IDX_IDX];\n      trieI = childTrieI;\n    }\n\n    // Add the child to the stack\n    key[top] = numChild + UTF8_BYTE_MIN;\n    stack[++top] = [trieI, childI + TRIE_NODE_CHILDREN_IDX, 0];\n\n    // Print value, if any\n    const valueIndex = tries[trieI][childI + TRIE_NODE_VALUE_IDX];\n    if (valueIndex !== TRIE_NULL) {\n      // Print separator if not first value\n      if (tail) {\n        stream.write(separator);\n      }\n      tail = true;\n      callbackFn(stream, key, top, valueIndex);\n    }\n  } while (top >= 0);\n}\n","import { Worker } from \"worker_threads\";\n\n/**\n * Creates a new Worker instance.\n *\n * @param workerPath - The path to the worker script.\n *\n * @returns A new Worker instance.\n */\nexport function createWorker(workerPath: string): Worker {\n  const worker = new Worker(workerPath);\n  worker.on(\"error\", (err) => {\n    throw err;\n  });\n  worker.on(\"messageerror\", (err) => {\n    throw err;\n  });\n  worker.on(\"exit\", (code) => {\n    if (code > 1 || code < 0) {\n      throw new Error(`Worker ${worker.threadId} exited with code ${code}`);\n    }\n  });\n  return worker;\n}\n\n/**\n * Executes a task on a Worker and returns a Promise that resolves with the response.\n *\n * @param worker - The Worker instance to execute the task.\n * @param req - The request to send to the worker.\n *\n * @returns A Promise that resolves with the response from the worker.\n */\nexport function exec<Req, Res>(worker: Worker, req: Req): Promise<Res> {\n  return new Promise<Res>((resolve) => {\n    worker.once(\"message\", resolve);\n    worker.postMessage(req);\n  });\n}\n","import { WriteStream, createWriteStream } from \"node:fs\";\nimport { Worker } from \"node:worker_threads\";\n\nimport type { MergeRequest } from \"./types/mergeRequest\";\nimport type { MergeResponse } from \"./types/mergeResponse\";\nimport type { ProcessRequest } from \"./types/processRequest\";\nimport type { ProcessResponse } from \"./types/processResponse\";\n\nimport {\n  ENTRY_MAX_LEN,\n  MAX_STATIONS,\n  STATION_NAME_MAX_LEN,\n} from \"./constants/constraints\";\nimport { CHUNK_SIZE_MIN, HIGH_WATER_MARK_OUT } from \"./constants/stream\";\nimport { MAX_WORKERS, MIN_WORKERS } from \"./constants/workers\";\nimport { clamp, getFileChunks } from \"./utils/stream\";\nimport { print } from \"./utils/utf8Trie\";\nimport { createWorker, exec } from \"./utils/worker\";\n\nexport async function run(\n  filePath: string,\n  workerPath: string,\n  maxWorkers: number,\n  outPath = \"\",\n): Promise<void> {\n  // Sanitize number of workers\n  maxWorkers = clamp(maxWorkers, MIN_WORKERS, MAX_WORKERS);\n\n  // Split the file into chunks. Creates 1 or fewer chunks per worker\n  const chunks = await getFileChunks(\n    filePath,\n    maxWorkers,\n    ENTRY_MAX_LEN,\n    CHUNK_SIZE_MIN,\n  );\n\n  // Adjust the number of workers to the number of chunks\n  maxWorkers = chunks.length;\n\n  // Initialize data\n  const valBuf = new SharedArrayBuffer((MAX_STATIONS * maxWorkers + 1) << 4);\n  const mins = new Int16Array(valBuf);\n  const maxes = new Int16Array(valBuf, 2);\n  const counts = new Uint32Array(valBuf, 4);\n  const sums = new Float64Array(valBuf, 8);\n  const tries = new Array<Int32Array>(maxWorkers);\n\n  // Create workers\n  const workers = new Array<Worker>(maxWorkers);\n  for (let i = 0; i < maxWorkers; ++i) {\n    workers[i] = createWorker(workerPath);\n  }\n\n  // Process each chunk\n  const tasks = new Array<Promise<unknown>>(maxWorkers);\n  for (let i = 0; i < maxWorkers; ++i) {\n    tasks[i] = exec<ProcessRequest, ProcessResponse>(workers[i], {\n      type: \"process\",\n      counts,\n      end: chunks[i][1],\n      filePath,\n      id: i,\n      maxes,\n      mins,\n      start: chunks[i][0],\n      sums,\n    }).then((res) => {\n      tries[res.id] = res.trie;\n    });\n  }\n\n  // Merge tries\n  for (let i = tasks.length - 1; i > 0; --i) {\n    const a = (i - 1) >> 1;\n    const b = i;\n    tasks[a] = tasks[a]\n      .then(() => tasks[b])\n      .then(() =>\n        exec<MergeRequest, MergeResponse>(workers[a], {\n          type: \"merge\",\n          a,\n          b,\n          counts,\n          maxes,\n          mins,\n          sums,\n          tries,\n        }),\n      )\n      .then((res) => {\n        for (const id of res.ids) {\n          tries[id] = res.tries[id];\n        }\n      });\n  }\n\n  // Terminate workers\n  for (let i = 0; i < maxWorkers; ++i) {\n    tasks[i] = tasks[i].then(() => workers[i].terminate());\n  }\n\n  // Wait for completion\n  await Promise.all(tasks);\n\n  // Print results\n  const out = createWriteStream(outPath, {\n    fd: outPath.length < 1 ? 1 : undefined,\n    flags: \"a\",\n    highWaterMark: HIGH_WATER_MARK_OUT,\n  });\n  const buffer = Buffer.allocUnsafe(STATION_NAME_MAX_LEN);\n  out.write(\"{\");\n  print(tries, buffer, 0, out, \", \", printStation);\n  out.end(\"}\\n\");\n\n  function printStation(\n    stream: WriteStream,\n    name: Buffer,\n    nameLen: number,\n    vi: number,\n  ): void {\n    const avg = Math.round(sums[vi << 1] / counts[vi << 2]);\n    stream.write(name.toString(\"utf8\", 0, nameLen));\n    stream.write(\"=\");\n    stream.write((mins[vi << 3] / 10).toFixed(1));\n    stream.write(\"/\");\n    stream.write((avg / 10).toFixed(1));\n    stream.write(\"/\");\n    stream.write((maxes[vi << 3] / 10).toFixed(1));\n  }\n}\n","import { CHAR_MINUS, CHAR_ZERO } from \"../constants/utf8\";\n\nexport const CHAR_ZERO_11 = 11 * CHAR_ZERO;\nexport const CHAR_ZERO_111 = 111 * CHAR_ZERO;\n\n/**\n * Converts an ASCII numeric string into an integer.\n *\n * Fastest.\n */\nexport function parseDouble(b: Buffer, min: number, max: number): number {\n  if (b[min] === CHAR_MINUS) {\n    ++min;\n    return min + 4 > max\n      ? CHAR_ZERO_11 - 10 * b[min] - b[min + 2]\n      : CHAR_ZERO_111 - 100 * b[min] - 10 * b[min + 1] - b[min + 3];\n  }\n  return min + 4 > max\n    ? 10 * b[min] + b[min + 2] - CHAR_ZERO_11\n    : 100 * b[min] + 10 * b[min + 1] + b[min + 3] - CHAR_ZERO_111;\n}\n\n/**\n * Converts an ASCII numeric string into an integer.\n *\n * Second fastest.\n */\nexport function parseDoubleFlat(b: Buffer, min: number, max: number): number {\n  const sign = -(b[min] === CHAR_MINUS);\n  b[min + ~sign] = CHAR_ZERO;\n  return (\n    ((100 * b[max - 4] + 10 * b[max - 3] + b[max - 1] - CHAR_ZERO_111) ^ sign) -\n    sign\n  );\n}\n\n/**\n * Converts an ASCII numeric string into an integer without branching.\n *\n * Inspired by {@link https://github.com/gunnarmorling/1brc/blob/main/src/main/java/dev/morling/onebrc/CalculateAverage_thomaswue.java#L68 | Quan Anh Mai's method}.\n *\n * Slowest.\n */\nexport function parseDoubleQuan(b: Buffer, min: number, max: number): number {\n  b[min - 1] = 0;\n  const sign = -(b[min] === CHAR_MINUS);\n  const signMask = -(min + 4 >= max) & sign & 0xff000000;\n  let v = b.readUint32BE(max - 4) & ~signMask & 0x0f0f000f;\n  v = (v & 0xff000000) * 0x19 + (v & 0x00ff0000) * 0x280 + (v << 22);\n  return ((v >>> 22) ^ sign) - sign;\n}\n","import { createReadStream } from \"node:fs\";\n\nimport type { ProcessRequest } from \"./types/processRequest\";\nimport type { ProcessResponse } from \"./types/processResponse\";\n\nimport { CHAR_SEMICOLON } from \"./constants/utf8\";\nimport { CHAR_NEWLINE } from \"./constants/utf8\";\nimport { ENTRY_MAX_LEN, MAX_STATIONS } from \"./constants/constraints\";\nimport { TRIE_NODE_VALUE_IDX, TRIE_NULL } from \"./constants/utf8Trie\";\nimport { getHighWaterMark } from \"./utils/stream\";\nimport { add, createTrie, mergeLeft } from \"./utils/utf8Trie\";\nimport { MergeRequest } from \"./types/mergeRequest\";\nimport { MergeResponse } from \"./types/mergeResponse\";\nimport { parseDouble } from \"./utils/parse\";\n\nexport async function run({\n  end,\n  filePath,\n  id,\n  start,\n  // Shared memory\n  counts,\n  maxes,\n  mins,\n  sums,\n}: ProcessRequest): Promise<ProcessResponse> {\n  // Check chunk size\n  if (start >= end) {\n    return { id, trie: createTrie(id, 0) };\n  }\n\n  // Initialize constants\n  let trie = createTrie(id);\n  let stations = id * MAX_STATIONS + 1;\n  const buffer = Buffer.allocUnsafe(ENTRY_MAX_LEN);\n\n  // Create the chunk stream\n  const stream = createReadStream(filePath, {\n    start,\n    end: end - 1,\n    highWaterMark: getHighWaterMark(end - start),\n  });\n\n  // For each chunk\n  let bufI = 0;\n  let leaf: number;\n  for await (const chunk of stream) {\n    // For each byte\n    const N = chunk.length;\n    for (let i = 0; i < N; ++i) {\n      // If not newline\n      if (chunk[i] !== CHAR_NEWLINE) {\n        buffer[bufI++] = chunk[i];\n        continue;\n      }\n\n      // Get semicolon\n      let semI = bufI - 4;\n      if (buffer[semI - 2] === CHAR_SEMICOLON) {\n        semI -= 2;\n      } else if (buffer[semI - 1] === CHAR_SEMICOLON) {\n        semI -= 1;\n      }\n\n      // Get temperature\n      const tempV = parseDouble(buffer, semI + 1, bufI);\n      bufI = 0;\n\n      // Add the station's name to the trie and get leaf index\n      [trie, leaf] = add(trie, buffer, 0, semI);\n\n      // If the station existed\n      if (trie[leaf + TRIE_NODE_VALUE_IDX] !== TRIE_NULL) {\n        // Update the station's value\n        updateStation(trie[leaf + TRIE_NODE_VALUE_IDX], tempV);\n      } else {\n        // Add the new station's value\n        trie[leaf + TRIE_NODE_VALUE_IDX] = stations;\n        newStation(stations++, tempV);\n      }\n    }\n  }\n\n  function newStation(index: number, temp: number): void {\n    mins[index << 3] = temp;\n    maxes[index << 3] = temp;\n    counts[index << 2] = 1;\n    sums[index << 1] = temp;\n  }\n\n  function updateStation(index: number, temp: number): void {\n    index <<= 3;\n    mins[index] = mins[index] <= temp ? mins[index] : temp;\n    maxes[index] = maxes[index] >= temp ? maxes[index] : temp;\n    ++counts[index >> 1];\n    sums[index >> 2] += temp;\n  }\n\n  return { id, trie };\n}\n\nexport function merge({\n  a,\n  b,\n  tries,\n  counts,\n  maxes,\n  mins,\n  sums,\n}: MergeRequest): MergeResponse {\n  function mergeStations(ai: number, bi: number): void {\n    ai <<= 3;\n    bi <<= 3;\n    mins[ai] = Math.min(mins[ai], mins[bi]);\n    maxes[ai] = Math.max(maxes[ai], maxes[bi]);\n    counts[ai >> 1] += counts[bi >> 1];\n    sums[ai >> 2] += sums[bi >> 2];\n  }\n  const ids = mergeLeft(tries, a, b, mergeStations);\n  return { ids, tries };\n}\n","import { availableParallelism } from \"node:os\";\nimport { fileURLToPath } from \"node:url\";\nimport { isMainThread, parentPort } from \"node:worker_threads\";\n\nimport { run as runMain } from \"./main\";\nimport { merge, run as runWorker } from \"./worker\";\nimport { Request } from \"./types/request\";\nimport { ProcessRequest } from \"./types/processRequest\";\nimport { MergeRequest } from \"./types/mergeRequest\";\n\nif (isMainThread) {\n  const workerPath = fileURLToPath(import.meta.url);\n  runMain(process.argv[2], workerPath, availableParallelism());\n} else {\n  parentPort!.addListener(\"message\", async (msg: Request) => {\n    if (msg.type === \"process\") {\n      parentPort!.postMessage(await runWorker(msg as ProcessRequest));\n    } else if (msg.type === \"merge\") {\n      parentPort!.postMessage(merge(msg as MergeRequest));\n    } else {\n      throw new Error(\"Unknown message type\");\n    }\n  });\n}\n"],"names":["MAX_STATIONS","STATION_NAME_MAX_LEN","ENTRY_MAX_LEN","HIGH_WATER_MARK_MIN","HIGH_WATER_MARK_MAX","HIGH_WATER_MARK_OUT","HIGH_WATER_MARK_RATIO","CHUNK_SIZE_MIN","MIN_WORKERS","MAX_WORKERS","CHAR_MINUS","CHAR_NEWLINE","CHAR_SEMICOLON","CHAR_ZERO","UTF8_BYTE_MIN","UTF8_BYTE_SPAN","clamp","value","min","max","getFileChunks","filePath","target","maxLineLength","minSize","file","open","size","chunkSize","buffer","chunks","start","end","res","newline","getHighWaterMark","TRIE_DEFAULT_SIZE","TRIE_GROWTH_FACTOR","TRIE_PTR_IDX_MEM","TRIE_PTR_MEM","TRIE_XPTR_ID_MEM","TRIE_XPTR_IDX_IDX","TRIE_XPTR_IDX_MEM","TRIE_XPTR_MEM","TRIE_NODE_ID_IDX","TRIE_NODE_ID_MEM","TRIE_NODE_VALUE_IDX","TRIE_NODE_VALUE_MEM","TRIE_NODE_CHILDREN_IDX","TRIE_NODE_CHILDREN_LEN","TRIE_NODE_CHILDREN_MEM","TRIE_NODE_MEM","TRIE_NULL","TRIE_SIZE_IDX","TRIE_SIZE_MEM","TRIE_ROOT_IDX","TRIE_ROOT_MEM","TRIE_ID_IDX","TRIE_MEM","add","trie","key","index","child","grow","createTrie","id","length","next","i","mergeLeft","tries","at","bt","mergeFn","grown","queue","Q","q","ai","bi","bvi","avi","bn","ri","rt","li","lt","print","trieIndex","stream","separator","callbackFn","stack","top","tail","trieI","childPtr","numChild","childI","childTrieI","valueIndex","createWorker","workerPath","worker","Worker","err","code","exec","req","resolve","run","maxWorkers","outPath","valBuf","mins","maxes","counts","sums","workers","tasks","a","b","out","createWriteStream","printStation","name","nameLen","vi","avg","CHAR_ZERO_11","CHAR_ZERO_111","parseDouble","stations","createReadStream","bufI","leaf","chunk","N","semI","tempV","updateStation","newStation","temp","merge","mergeStations","isMainThread","fileURLToPath","_documentCurrentScript","runMain","availableParallelism","parentPort","msg","runWorker"],"mappings":"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"}